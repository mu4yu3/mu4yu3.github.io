<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lich&#39;s Blog</title>
  
  <subtitle>Just do IT.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://mu4yu3.github.io/"/>
  <updated>2018-03-15T14:07:18.000Z</updated>
  <id>https://mu4yu3.github.io/</id>
  
  <author>
    <name>Lich</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何挑选手机</title>
    <link href="https://mu4yu3.github.io/2018/03/15/how_to_choose_a_smartphone/"/>
    <id>https://mu4yu3.github.io/2018/03/15/how_to_choose_a_smartphone/</id>
    <published>2018-03-15T09:42:37.000Z</published>
    <updated>2018-03-15T14:07:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近，给自己选了手机，给家人选了手机。</p><p>总结了一下（仅为自身考虑的）心得，供大家参考。</p><p>一共有13个问题，不区分顺序。</p><a id="more"></a><h2 id="选择一个操作系统"><a href="#选择一个操作系统" class="headerlink" title="选择一个操作系统"></a>选择一个操作系统</h2><ol><li>iPhone使用的iOS系统，好用，（相对）安全，权限干净，与其他apple设备兼容。</li><li>Android，Google出品，灵活性好，可定制化程度高，价格便宜。</li><li>其他系统，比如windows phone、Ubuntu。</li></ol><p>如果没有特殊原因，不用考虑其他系统。<br>（基本上，连他们的开发厂商都已经放弃了这些系统，比如M$）</p><p>在Android和iPhone中选一个就好了。</p><h2 id="选一个可以接受的价格区间"><a href="#选一个可以接受的价格区间" class="headerlink" title="选一个可以接受的价格区间"></a>选一个可以接受的价格区间</h2><p>这和自己的收入相关，也和其他问题有一定的相关性。</p><p>例如同时代，同样配置的设备，iPhone总是比Android设备要贵一些。</p><p>如果iPhone和Android设备价格相同，那么iPhone在配置上总是要低一些的。</p><p><del>但iPhone配置低不一定体验不好，相反，通常iOS的优化会更好一点，流畅度更高些。</del></p><p>以前是这样，现在不好说，尤其是对比Google亲儿子，呵呵。</p><h2 id="考虑手机淘汰的时间"><a href="#考虑手机淘汰的时间" class="headerlink" title="考虑手机淘汰的时间"></a>考虑手机淘汰的时间</h2><p>现在的手机设备，淘汰很快，一般2~3年已经算是超龄服役了。</p><p>这里可以参考厂商对设备的承诺。</p><p>Apple一般在iPhone发售3年左右，iOS更新就不再支持旧设备了。</p><p>Google承诺了Pixel设备3年的系统更新。</p><p>通常如果系统不能再继续更新，尤其是安全补丁不能再更新，意味着这个设备已经被强制退役了。</p><p>不考虑摔坏，进水等意外情况。结合预计使用的时间，再加上价格区间，可以计算平均到每一天的使用成本。</p><h2 id="考虑现有的设备、系统、软件兼容性"><a href="#考虑现有的设备、系统、软件兼容性" class="headerlink" title="考虑现有的设备、系统、软件兼容性"></a>考虑现有的设备、系统、软件兼容性</h2><p>如果平时使用mac、ipad，在AppStore买了一堆软件，那么显然使用iPhone是最佳选择。</p><p>如果是Gmail、或者其他Google产品的重度用户，平时用M$的office比较多，那么可以考虑选Android。</p><h2 id="考虑依赖的套件"><a href="#考虑依赖的套件" class="headerlink" title="考虑依赖的套件"></a>考虑依赖的套件</h2><p>iOS提供Siri、facetime、iCloud、imessage。</p><p>Android提供Gmail、Google Drive。</p><p>如果你非要使用Cortana，那么可以考虑Windows Phone。（啊哈）</p><p>其实为了减少对某个平台的依赖性，用户往往会对强制单一平台的产品，有天然的抵制心理。</p><p>从用户层面上来说，支持多平台的app产品比较友好，但对厂商来说，这样不容易形成技术壁垒。</p><h2 id="考虑常用的软件"><a href="#考虑常用的软件" class="headerlink" title="考虑常用的软件"></a>考虑常用的软件</h2><p>比如银行的app。</p><p>因为众所周知的原因，很多国产app是不在 Google play 市场上架的。</p><h2 id="考虑硬件问题"><a href="#考虑硬件问题" class="headerlink" title="考虑硬件问题"></a>考虑硬件问题</h2><ol><li>根据sim卡的运营商，考虑网络问题（其实也是芯片问题）</li><li>考虑<code>运行内存</code>和<code>存储内存</code>空间大小的问题，包括是否可以<code>扩展存储</code>。</li><li>考虑屏幕尺寸、配置</li><li>考虑芯片配置（包括cpu速度等）</li><li>考虑摄像头的配置</li></ol><p>其实每一项都可以单列，这里把它们汇总了。</p><p>需要注意的是，有些硬件不适合单纯的比较参数。数字上的差别不一定能反映真实的效果。</p><p>有些硬件，不会被使用（比如指纹），又或者通常都具备（比如GPS），所以不列入特别考虑。</p><h2 id="考虑有中国特色的问题"><a href="#考虑有中国特色的问题" class="headerlink" title="考虑有中国特色的问题"></a>考虑有中国特色的问题</h2><p>如果选择iPhone，需要考虑iCloud国籍问题。</p><p>如果选择Android，需要考虑访问Google的问题。</p><h2 id="如果选择Android的问题"><a href="#如果选择Android的问题" class="headerlink" title="如果选择Android的问题"></a>如果选择Android的问题</h2><p>如果买的是Google的亲儿子，那么这一项就不用额外考虑了。</p><p>如果是其他品牌。那么需要考虑刷第三方rom的问题。</p><p>第三方rom首选<a href="http://lineageos.org/" target="_blank" rel="noopener">lineageOS</a>，它是CyanogenMod的继任者。</p><p>访问lineageOS的<a href="https://wiki.lineageos.org/devices/" target="_blank" rel="noopener">wiki</a>，可以查看哪些手机纳入了官方支持范围。</p><p>因为lineageOS是开源的项目，如果自己的手机型号，官方不支持，还可以去<a href="https://forum.xda-developers.com" target="_blank" rel="noopener">XDA-Developers</a>查下非官方的开发者。</p><p>根据经验，品牌大，使用人数多，销售范围广，使用高通的芯片，比较容易被支持。</p><p>比如Samsung、Sony、LG，都有很多型号被官方或民间支持。</p><p>国产品牌中，Xiaomi和OnePlus，支持的也比较多。</p><p>比较坑的是：Huawei、ZTE、Nubia这些，品牌不算小，支持的型号很少。</p><p>手边上有4个旧设备，分别是：</p><ol><li>Samsung Galaxy S II i9100g，使用了Texas Instruments OMAP 4430的芯片，非官方lineageOS支持。</li><li>红米1，联发科 MT6589T的芯片，没有lineageOS的rom。</li><li>华为 Mate 7，麒麟925，海思的芯片，没有lineageOS的rom。</li><li>Google Nexus 4，官方lineageOS支持，目前支持到Android 7.1.2版本，也就是lineageOS 14.1版本。</li></ol><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>结果选择了Android。</p><p>感觉没有13个问题的读者，可以再数数。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近，给自己选了手机，给家人选了手机。&lt;/p&gt;
&lt;p&gt;总结了一下（仅为自身考虑的）心得，供大家参考。&lt;/p&gt;
&lt;p&gt;一共有13个问题，不区分顺序。&lt;/p&gt;
    
    </summary>
    
    
      <category term="smartphone" scheme="https://mu4yu3.github.io/tags/smartphone/"/>
    
  </entry>
  
  <entry>
    <title>Pixel2 游记</title>
    <link href="https://mu4yu3.github.io/2018/02/25/my_pixel2/"/>
    <id>https://mu4yu3.github.io/2018/02/25/my_pixel2/</id>
    <published>2018-02-25T05:46:04.000Z</published>
    <updated>2018-03-06T04:39:35.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Now this is not the end, it is not even the beginning of the end.<br>But it is, perhaps, the end of the beginning.</p><p>  –Winston Churchill</p></blockquote><p>自从上一个iPhone5S掉海水，一直在iPhone和Android之间摇摆。</p><p>一条新闻促使我下定了决心：<a href="http://www.williamlong.info/archives/5214.html" target="_blank" rel="noopener">苹果中国iCloud服务转由国企运营管理</a></p><p>新年前，拜托了友人小鱼，在Google store下单购买了一部无锁版的pixel2。</p><p>不远两万里从美国带回到国内。</p><p>今天，友人携带着这部pixel2，踏上返美的归途。</p><p>感谢我的友人。</p><p>千里鹅毛，尚且礼轻情重，更何况是带着一部pixel2，绕了地球一圈。</p><a id="more"></a><h2 id="人生若只如初见"><a href="#人生若只如初见" class="headerlink" title="人生若只如初见"></a>人生若只如初见</h2><p>时间拨回到新年初三，与友人相聚，对饮四人。</p><p>那是第一次看到我的pixel2。</p><p>拆箱犹豫了一下，想着实用为主，没有拍照。</p><p>先看说明书和附件：</p><ul><li>充电插头 x 1</li><li>USB C to USB C 数据线 x 1</li><li>USB C to USB 转接头 x 1 （用来导入旧手机数据）</li><li>USB C to 耳机接口 x 1</li></ul><p>心里咯噔了一下，家里的笔记本很久没有更新了。现用的笔记本没有USB C 的接口。</p><p>之前没做功课，也没准备USB C 的转接口，看来 <code>adb</code> 是暂时用不起来了。</p><p>不过这也不是什么大问题。</p><p>开机，初始化，上梯子，登陆Google账号，看到首屏。</p><p>那是一个海滩，还有海浪拍岸的动态效果。</p><p>简单试了一下拍照。</p><p>一向不在意外貌，屏幕，拍照，但也觉得好看，好看，好看。</p><p>第一次登陆进去，会自动更新google play，下载Google全家桶软件。</p><p>直接睡觉去，睡醒了，自然更新完成。</p><p>这时候发现了第一个问题：OTA的update始终报错，无法完成。</p><h2 id="衣带渐宽终不悔，为伊消得人憔悴"><a href="#衣带渐宽终不悔，为伊消得人憔悴" class="headerlink" title="衣带渐宽终不悔，为伊消得人憔悴"></a>衣带渐宽终不悔，为伊消得人憔悴</h2><p>以前有一个nexus7的平板，OTA的update都是挂上梯子就可以下载。</p><p>这次pixel2的OTA更新不了，倒也不太着急，毕竟还可以直接刷Factory Images。</p><p>上google，找镜像，到<a href="https://developers.google.com/android/images" target="_blank" rel="noopener">官网</a>。</p><p>看到这样一句话：</p><blockquote><p>For Pixel 2: To flash the bootloader, Pixel 2’s boot loader must be updated to at least Oreo MR1’s version first. This may be done by applying an over-the-air (OTA) update, or sideloading a full OTA with the instructions on that page.</p></blockquote><p>打开设置，查看版本，还是OPD1.170816.010，这是8.0.0的版本。</p><p>看来得先升级版本，可OTA升不了，只能刷 FULL OTA Images。</p><p>新年初四去拜年，在另一位友人家中看到一根<a href="https://item.mi.com/1164700050.html" target="_blank" rel="noopener">小米二合一数据线</a>。</p><p>同时支持Type-C和Micro USB，不错。</p><p>想着新年快递不行，等到新年初六，跑了一趟小米之家，现场买了一根回来。</p><p>按照<a href="https://developers.google.com/android/ota" target="_blank" rel="noopener">官方文档</a>操作，先下载了2个镜像：</p><ul><li><p><a href="https://dl.google.com/dl/android/aosp/walleye-ota-opm1.171019.011-4f58f0f0.zip" target="_blank" rel="noopener">8.1.0 (OPM1.171019.011, Dec 2017)</a><br>初版8.1.0的镜像，<br>SHA-256 Checksum：<br>4f58f0f0cd1e90db605bdd918decac55ce166ea999f437a50aaf388dc6c7fb11</p></li><li><p><a href="https://dl.google.com/dl/android/aosp/walleye-ota-opm1.171019.019-5b2af7a9.zip" target="_blank" rel="noopener">8.1.0 (OPM1.171019.019, Feb 2018)</a><br>最新的镜像，<br>SHA-256 Checksum：<br>5b2af7a9f00da30a2299868e72df2aeffe400d74a470b39586ce77f6962caaec</p></li></ul><p>连接手机电脑，下载最新版的<a href="https://developer.android.com/studio/releases/platform-tools.html" target="_blank" rel="noopener">Android SDK Platform-Tools</a></p><p>设置 -&gt; 关于手机 -&gt; 打开<code>开发者选项</code></p><p>切换到<code>开发者选项</code> -&gt; 打开<code>USB debugging</code></p><p>进入recovery模式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb reboot recovery</span><br></pre></td></tr></table></figure></p><p>按住电源键，按音量上键，选择<code>Apply update from ADB</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb devices</span><br><span class="line">adb sideload walleye-ota-opm1.171019.019-5b2af7a9.zip</span><br></pre></td></tr></table></figure></p><p>先后试了2个OTA的包，都升级成功。</p><h2 id="蓦然回首，bug却在，灯火阑珊处。"><a href="#蓦然回首，bug却在，灯火阑珊处。" class="headerlink" title="蓦然回首，bug却在，灯火阑珊处。"></a>蓦然回首，bug却在，灯火阑珊处。</h2><p>作为一个普通用户来说，这时候手机已经更新到最新状态。</p><p>可以下载app，将旧手机的资料转移，可以正常使用了。</p><p>只因为我在<code>开发者选项</code>多看了一看，发现<code>OEM unlocking</code>开关是灰色的。</p><p>纳尼！？说好的无锁版呢？</p><p>开始了漫漫debug之路。</p><ol><li>恢复出厂设置（有2种，在UI界面中，在recovery中）</li><li>初始化，开wifi，上梯子，进系统，在设置 -&gt; 关于手机 -&gt; 打开<code>开发者选项</code></li><li>切换到<code>开发者选项</code>，打开<code>USB debugging</code>和<code>OEM unlocking</code>（第一次的时候，<code>OEM unlocking</code>是可以打开的）</li><li>这个时候，无论是关机，重启，或者放置一段时间，<code>OEM unlocking</code>始终是激活状态。</li><li>关机重启，进入fastboot模式</li><li>通过数据线连接手机和PC (试了win10和linux)</li><li>检查设备连接良好，设备已经识别</li><li><p>命令检查设备已识别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./fastboot devices</span><br><span class="line">FAXXXXXXXXXX    fastboot</span><br></pre></td></tr></table></figure></li><li><p>查询设备信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">./fastboot oem device-info</span><br><span class="line">(bootloader) Verity mode: true</span><br><span class="line">(bootloader) Device unlocked: false</span><br><span class="line">(bootloader) Device critical unlocked: true</span><br><span class="line">(bootloader) Charger screen enabled: true OKAY</span><br><span class="line">[  0.025s] finished. total time: 0.025s</span><br></pre></td></tr></table></figure></li><li><p>尝试解锁（测试了 <code>oem unlock</code> 或者 <code>flashing unlock</code>)，均失败。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">./fastboot oem unlock</span><br><span class="line">FAILED (remote: Flashing Unlock is not allowed</span><br><span class="line">)</span><br><span class="line">finished. total time: 0.010s</span><br><span class="line">./fastboot flashing unlock</span><br><span class="line">FAILED (remote: Flashing Unlock is not allowed</span><br><span class="line">)</span><br><span class="line">finished. total time: 0.009s</span><br></pre></td></tr></table></figure></li><li><p>重启手机</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./fastboot reboot</span><br><span class="line">finished. total time: 5.035s</span><br></pre></td></tr></table></figure></li><li><p>回到<code>开发者选项</code>，这时候<code>OEM Unlocking</code>已经变成灰色，不可切换状态。</p></li></ol><p>然后就是不断的重复这12个步骤。</p><p>期间不断调整各个步骤的实现方式，比如：</p><ol><li>使用UI回复出厂，使用recovery回复出厂。</li><li>初始化使用中文、英文；登陆Google账号，跳过登陆账号。</li><li>使用sim卡，不使用sim卡。</li><li>使用<code>adb</code>命令重启，使用按键重启。</li><li>使用不同的PC、接口、操作系统、adb版本……</li></ol><p>再把这些选项组合，穷举各种可能性……漫长的工作量……</p><p>最后，全部失败。</p><h2 id="独上高楼-望尽天涯"><a href="#独上高楼-望尽天涯" class="headerlink" title="独上高楼 望尽天涯"></a>独上高楼 望尽天涯</h2><p>开始在网上找了一下相关资料，xda上有人遇到相同的问题。</p><ul><li><a href="https://forum.xda-developers.com/pixel-2/help/oem-unlocking-issue-t3716668" target="_blank" rel="noopener">OEM Unlocking issue</a></li></ul><p>这人联系了Google，通过RMA换了一部新手机，问题解决了。</p><p>开始联系Google，登陆<a href="https://support.google.com/store" target="_blank" rel="noopener">Google Store Help</a>，点击<a href="https://support.google.com/store/contactflow?hl=en" target="_blank" rel="noopener">CONTACT US</a></p><p>不方便电话回访（没有美国手机号，留了中国手机号，无反馈 o_o! ），所以只好留了邮件地址，写明问题，等待回信。</p><p>同时到<a href="https://productforums.google.com/forum/?utm_medium=email&amp;utm_source=footer#!forum/phone-by-google" target="_blank" rel="noopener">Google产品论坛</a>，</p><p>新建了一个主题：<a href="https://productforums.google.com/forum/?utm_medium=email&amp;utm_source=footer#!topic/phone-by-google/lATXL2Zv53U" target="_blank" rel="noopener">Google Pixel 2 OEM Unlocking issue</a></p><p>有专家认为：</p><blockquote><p>If your device was purchased from the Google Store I don’t believe the bootloader should be locked. I think only the ones from Verizon are OEM locked.  I would suggest contacting support.</p></blockquote><p>查看了Google的问题跟踪系统，看到了 issue：</p><p><a href="https://issuetracker.google.com/issues/68897739" target="_blank" rel="noopener">Can NOT OEM unlock slider in Dev Options Pixel 2 HTC OPD1.170816.010</a></p><p>下面一百多个跟帖，显示这个问题绝对不是偶发。</p><p>目前可能的原因有2个：</p><ol><li>大概率，有一批Pixel2出厂即带bug（不是所有的，有人买了2台，1台有bug，1台可解锁），未来可能会因为update修复这个bug。</li><li>小概率，google发货的时候，把部分Verizon有锁版，当成无锁版，发货出来了（无法证实这个可能）。</li></ol><p>犹豫再三，决定拜托友人带回美国，尝试通过RMA换一部新手机。</p><p>对我来说，无法unlock bootloader的Android，还不如一部iPhone。</p><p>新年初九，夜，将Pixel2交还给友人。</p><p>感谢我的友人。</p><h2 id="夜来幽梦忽还乡"><a href="#夜来幽梦忽还乡" class="headerlink" title="夜来幽梦忽还乡"></a>夜来幽梦忽还乡</h2><p>6天，144个小时。</p><h2 id="2018-3-6-12-39-35-更新"><a href="#2018-3-6-12-39-35-更新" class="headerlink" title="2018/3/6 12:39:35 更新"></a>2018/3/6 12:39:35 更新</h2><p>友人已经帮我联系了Google，更换的新机已经入手。</p><p>接下来，就看这部新机，什么时候再跨过半个地球，来到中国。</p><p>也看Google的品控，会不会两次让人失望。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Now this is not the end, it is not even the beginning of the end.&lt;br&gt;But it is, perhaps, the end of the beginning.&lt;/p&gt;
&lt;p&gt;  –Winston Churchill&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;自从上一个iPhone5S掉海水，一直在iPhone和Android之间摇摆。&lt;/p&gt;
&lt;p&gt;一条新闻促使我下定了决心：&lt;a href=&quot;http://www.williamlong.info/archives/5214.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;苹果中国iCloud服务转由国企运营管理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;新年前，拜托了友人小鱼，在Google store下单购买了一部无锁版的pixel2。&lt;/p&gt;
&lt;p&gt;不远两万里从美国带回到国内。&lt;/p&gt;
&lt;p&gt;今天，友人携带着这部pixel2，踏上返美的归途。&lt;/p&gt;
&lt;p&gt;感谢我的友人。&lt;/p&gt;
&lt;p&gt;千里鹅毛，尚且礼轻情重，更何况是带着一部pixel2，绕了地球一圈。&lt;/p&gt;
    
    </summary>
    
    
      <category term="pixel2" scheme="https://mu4yu3.github.io/tags/pixel2/"/>
    
      <category term="OEM unlock" scheme="https://mu4yu3.github.io/tags/OEM-unlock/"/>
    
      <category term="bootloader" scheme="https://mu4yu3.github.io/tags/bootloader/"/>
    
  </entry>
  
  <entry>
    <title>Let’s Encrypt的泛域名支持</title>
    <link href="https://mu4yu3.github.io/2018/01/29/letsencrypt_wildcard_certificates/"/>
    <id>https://mu4yu3.github.io/2018/01/29/letsencrypt_wildcard_certificates/</id>
    <published>2018-01-29T03:33:46.000Z</published>
    <updated>2018-01-29T03:33:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>一直记着2018年1月，Let’s Encrypt将添加泛域名的支持。</p><p>因为之前的证书到2月1日到期，所以也没有及时更新。</p><p>刚刚准备更新证书的时候发现，<a href="https://certbot.eff.org/faq/#will-let-s-encrypt-issue-wildcard-certificates" target="_blank" rel="noopener">certbot</a>还没有支持泛域名。</p><a id="more"></a><p>查了一下，原来Let’s Encrypt在<a href="https://letsencrypt.org/2017/07/06/wildcard-certificates-coming-jan-2018.html" target="_blank" rel="noopener">1月4日放出了一个公共测试api，到2月27日才完全可用</a>。</p><p>总觉得存在疑似“跳票”行为，不过也有可能是自己误解了。</p><p>好吧，继续耐心等待就好。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直记着2018年1月，Let’s Encrypt将添加泛域名的支持。&lt;/p&gt;
&lt;p&gt;因为之前的证书到2月1日到期，所以也没有及时更新。&lt;/p&gt;
&lt;p&gt;刚刚准备更新证书的时候发现，&lt;a href=&quot;https://certbot.eff.org/faq/#will-let-s-encrypt-issue-wildcard-certificates&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;certbot&lt;/a&gt;还没有支持泛域名。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Let’s Encrypt" scheme="https://mu4yu3.github.io/tags/Let%E2%80%99s-Encrypt/"/>
    
      <category term="Wildcard Certificates" scheme="https://mu4yu3.github.io/tags/Wildcard-Certificates/"/>
    
      <category term="泛域名" scheme="https://mu4yu3.github.io/tags/%E6%B3%9B%E5%9F%9F%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>智能家庭</title>
    <link href="https://mu4yu3.github.io/2018/01/22/smart_home/"/>
    <id>https://mu4yu3.github.io/2018/01/22/smart_home/</id>
    <published>2018-01-22T12:02:53.000Z</published>
    <updated>2018-01-24T15:20:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>家里有闲置的Android设备，有不限时、不限流量、拥有公网IP的宽带，总想着把它们利用起来。</p><p>Android基于一个修改版的linux内核，有大把的开源软件可以运行在这个操作系统上。</p><p>然而有一个问题，就是锂电池的使用与寿命，虽说是闲置、淘汰了的Android设备，但始终插着电源线充电显然不妥。</p><p>比较理想的方式是，建立一个自动化的充电机制：</p><p><strong>Android设备始终插着电源线，但并不是始终充电。当电池电量低（低于20%）时，能够自动启动充电，而电量高（超过90%）时，自动关闭充电。</strong></p><p>最初使用了一个<a href="https://www.mi.com/mj-socket/" target="_blank" rel="noopener">米家智能插座 基础版</a>来实现。</p><p>这里吐槽一下<a href="https://home.mi.com/" target="_blank" rel="noopener">米家</a>app，触发插座开关的可选项实在是太少，也没有提供公开的API。</p><p>无奈已经买了硬件，自己挖的坑，自己填。</p><p>过程不细说了（如果有感兴趣的读者留言，可以考虑另外写一篇），结果是：</p><p>使用Android下的busybox中的crontab，周期性的检查 <code>/sys/class/power_supply/battery</code> 下的电量信息。</p><p>通过shell脚本，判断电量后，使用 <code>adb input keyevent</code> 和 <code>adb input swipe</code> 模拟屏幕操作。</p><p>使用米家app，把智能插座usb口的开关，放两个快捷方式在Android的桌面上，通过模拟屏幕操作点击。</p><p>如此实现了自动化充电的机制，这时可以把Android设备视作一个linux server，或者说，更像是一个Raspberry Pi，可以放飞自我了。</p><a id="more"></a><h2 id="新的格局"><a href="#新的格局" class="headerlink" title="新的格局"></a>新的格局</h2><p>最近对HomeKit比较感兴趣。</p><p>原本有一个iPhone 5s，升级了iOS11，正准备折腾一下HomeKit，结果这个手机在苏梅岛附近的Ko Ra Thian进了海水，上岸后没用了。</p><p>计划搁浅。</p><p>回来以后研究了一下，意外发现了2个开源项目：</p><p><a href="https://github.com/nfarina/homebridge" target="_blank" rel="noopener">Homebridge</a>，<br>一个轻量级Node.js server，可以模拟iOS HomeKit API。</p><p><a href="https://github.com/home-assistant/home-assistant" target="_blank" rel="noopener">Home Assistant</a>，<br>一个可以检测和控制智能家居设备的自动化平台，基于python3。</p><p>因为已经没有了iPhone，所以Homebridge就暂时不管它了。仔细看了一下Home Assistant，新的格局出现了，充电自动化的机制可以转化为：</p><ol><li>在Android中安装<a href="https://play.google.com/store/apps/details?id=ru.meefik.linuxdeploy" target="_blank" rel="noopener">Linux Deploy</a>或者<a href="https://play.google.com/store/apps/details?id=com.termux" target="_blank" rel="noopener">Termux</a>，提供python3的运行环境。</li><li>安装python3环境，提供Home Assistant的运行环境。</li><li>使用Home Assistant连接米家的智能插座、获取Android的电量信息，制定自动化的规则。</li></ol><p>这样做至少有3个好处：</p><ol><li>避免了因使用adb模拟点击，偶尔出现的失效现象，以及点亮屏幕浪费的电力。</li><li>在Home Assistant中可以比较方便的添加、修改、删除自定义规则，比shell script方便，并且有相对更完善的log记录。</li><li>可以打破米家app的局限；可以和其他品牌的设备联动；可以有更多的自定义触发、自定义条件。</li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>在实现的过程中，还是有一些意外情况发生的，好在最后都解决了。记录如下：</p><h3 id="安装Linux-Deploy"><a href="#安装Linux-Deploy" class="headerlink" title="安装Linux Deploy"></a>安装Linux Deploy</h3><p>Linux Deploy与Termux这2个都是Android中的神器，都是开源软件，但又各有区别。</p><p><a href="https://github.com/meefik/linuxdeploy" target="_blank" rel="noopener">Linux Deploy</a>，<br>在Android系统中安装一个完整的linux系统，可以选择多个发行版本，如fedora、debian、arch等。</p><p><a href="https://github.com/termux/termux-app" target="_blank" rel="noopener">Termux</a>，<br>在Android系统提供了一个terminal，并提供了一个类debian的linux环境。</p><p>Termux有一个限制，要求Android系统至少在5.0版本以上，有网友提出了低于5版本的支持请求，但<a href="https://github.com/termux/termux-app/issues/6" target="_blank" rel="noopener">被作者拒绝</a>了。Termux的好处是不强制要求root权限。</p><p>Linux Deploy对Android版本没有5.0的限制要求，但要求root权限。</p><p>这里再吐槽一下，家里闲置的是一位长辈淘汰下来的红米手机，有比较<a href="http://www.miui.com/search.php?mod=forum&amp;searchid=3764464&amp;orderby=dateline&amp;ascdesc=desc&amp;searchsubmit=yes&amp;kw=闪屏&amp;month=&amp;refineSearch=0" target="_blank" rel="noopener">严重的闪屏问题</a>。</p><p>而且<a href="http://www.miui.com/download-82.html#131" target="_blank" rel="noopener">对应的miui</a>已经升级到8版本，可使用的还是Android4.4版本。</p><p>所以这里使用了Linux Deploy。</p><p>国内的手机没有google play，红米也没有CyanogenMod或者LineageOS的rom。</p><p>所以先安装<a href="https://f-droid.org/zh_Hans/" target="_blank" rel="noopener">F-Droid</a>，然后安装<a href="https://f-droid.org/zh_Hans/packages/com.github.yeriomin.yalpstore/" target="_blank" rel="noopener">Yalp Store</a>。</p><p>Yalp Store可以从Google Play Store下载apk安装包。</p><p>安装Linux Deploy的过程，可以参考这3篇文章：<br><a href="https://github.com/meefik/linuxdeploy/wiki/How-to-use-application" target="_blank" rel="noopener">How to use application</a>、<br><a href="https://mlapp.cn/134.html" target="_blank" rel="noopener">Linux Deploy:在Android上部署Linux</a>、<br><a href="https://mlapp.cn/189.html" target="_blank" rel="noopener">备选方案:在Linux Deploy上使用镜像部署Linux系统</a></p><p>在这里，把一张8G的TF卡格式化为ext4格式，在Linux Deploy设置安装类型为磁盘，安装路径定位到TF卡。</p><p>安装了Fedora 27版本的系统，安装常用的软件（ssh、tmux、vim、git等），安装python3的环境：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dnf install python3 python3-pip python3-virtualenv</span><br></pre></td></tr></table></figure><h3 id="安装Home-Assistant"><a href="#安装Home-Assistant" class="headerlink" title="安装Home Assistant"></a>安装Home Assistant</h3><p>python3环境准备好以后，使用<code>virtualenv</code>建立一套“隔离”的python运行环境。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mkdir homeassistant</span><br><span class="line">cd homeassistant/</span><br><span class="line">python3 -m virtualenv venv</span><br><span class="line">source venv/bin/activate</span><br><span class="line">python3 -m pip install homeassistant</span><br><span class="line">hass --open-ui</span><br></pre></td></tr></table></figure><p>如果想要把hass运行在后台可以执行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hass --open-ui --daemon</span><br></pre></td></tr></table></figure><p>安装和启动hass的过程中，一般会自动安装有依赖关系的软件。</p><p>如果有无法自动安装的，可以根据给出的错误提示，逐个寻找对应的软件安装。</p><p>如果想偷懒，可以一股脑把常用的编译工具都装上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dnf groupinstall &quot;C Development Tools and Libraries&quot;</span><br></pre></td></tr></table></figure><p>有时候会提示某个库文件没找到，可以通过 <code>dnf provides</code> 命令来寻找对应的安装包，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf provides */opensslv.h</span><br></pre></td></tr></table></figure><p>根据给出的提示，安装对应的软件包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dnf install openssl-devel</span><br></pre></td></tr></table></figure><p>安装Home Assistant过程可以参考：<br><a href="https://home-assistant.io/getting-started/" target="_blank" rel="noopener">installation instructions</a>、<br><a href="https://sspai.com/post/39881" target="_blank" rel="noopener">入门智能家居，从 IFTTT 到 HomeKit 自动化（二）</a>、<br><a href="https://www.hachina.io/docs/355.html" target="_blank" rel="noopener">在Linux（树莓派）中安装Python3和HomeAssistant</a></p><h3 id="配置Home-Assistant"><a href="#配置Home-Assistant" class="headerlink" title="配置Home Assistant"></a>配置Home Assistant</h3><p>Home Assistant目前支持959种<a href="https://home-assistant.io/components/" target="_blank" rel="noopener">components</a>，分别可以实现不同的扩展功能。</p><p>这里用到了2个：</p><p><a href="https://home-assistant.io/components/sensor.linux_battery/" target="_blank" rel="noopener">Linux Battery</a>，<br>用来监控Android的电量信息。</p><p><a href="https://home-assistant.io/components/switch.xiaomi_miio/" target="_blank" rel="noopener">Xiaomi Smart WiFi Socket and Smart Power Strip</a>，<br>用来连接和控制小米智能插座。</p><p>这里遇到了一个问题，Linux Battery默认监控的目录类似 <code>/sys/class/power_supply/BAT1</code>，而Android默认的目录是 <code>/sys/class/power_supply/battery</code>。<br>所以按照默认的配置，启动hass时候，日志会报出”No battery found”的错误。</p><p>为了添加Android的支持，贡献了在github的<a href="https://github.com/home-assistant/home-assistant/pull/11852" target="_blank" rel="noopener">First pull request</a>。</p><p>成功解决电量监控，下一步是连接小米智能插座。</p><p>使用这篇文章<a href="https://home-assistant.io/components/vacuum.xiaomi_miio/#retrieving-the-access-token" target="_blank" rel="noopener">Retrieving the Access Token</a>中描述的方法，先使用米家app连接设备，然后将 <code>/data/data/com.xiaomi.smarthome/databases/miio2.db</code> 用 <code>sqlite3</code> 打开。</p><p>使用sql命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name,localIP,token from devicerecord;</span><br></pre></td></tr></table></figure><p>获取Token，按照文档格式要求写入配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">switch:</span><br><span class="line">  - platform: xiaomi_miio</span><br><span class="line">    name: Original Xiaomi Mi Smart WiFi Socket</span><br><span class="line">    host: 192.168.130.59</span><br><span class="line">    token: YOUR_TOKEN</span><br></pre></td></tr></table></figure><p>最后一步是编写自动化规则，可以参考<a href="https://home-assistant.io/docs/automation/editor/" target="_blank" rel="noopener">官方文档</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># Example automations.yaml entry</span><br><span class="line">- id: my_unique_id  # &lt;-- Required for editor to work.</span><br><span class="line">  alias: 90% USB Auto Shutdown</span><br><span class="line">  trigger:</span><br><span class="line">  - above: &apos;90&apos;</span><br><span class="line">    entity_id: sensor.battery</span><br><span class="line">    platform: numeric_state</span><br><span class="line">  condition:</span><br><span class="line">  - condition: state</span><br><span class="line">    entity_id: switch.original_xiaomi_mi_smart_wifi_socket_usb</span><br><span class="line">    state: &apos;on&apos;</span><br><span class="line">  action:</span><br><span class="line">  - data:</span><br><span class="line">      entity_id: switch.original_xiaomi_mi_smart_wifi_socket_usb</span><br><span class="line">    service: switch.turn_off</span><br></pre></td></tr></table></figure><p>以上规则实现了：当电池电量在90%以上时，如果小米插座的usb口是通电的，自动将其关闭。</p><p>同理设置当电量低于40%时，如果usb是不通电的，自动将其打开。</p><p>为什么是40%，而不是最初设想的20%。</p><p>接着吐槽小米，这个红米手机电量一旦低于40%，就开始断崖式下降，几乎没几分钟就要停电关机了。</p><p>而电量侦测是周期性的，并不是实时的，所以需要有一定的弹性空间。</p><h2 id="放飞自我"><a href="#放飞自我" class="headerlink" title="放飞自我"></a>放飞自我</h2><p>解决了电量的后顾之忧，可以安心使用了。</p><p>发挥想象力，可以做的事儿太多了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h2&gt;&lt;p&gt;家里有闲置的Android设备，有不限时、不限流量、拥有公网IP的宽带，总想着把它们利用起来。&lt;/p&gt;
&lt;p&gt;Android基于一个修改版的linux内核，有大把的开源软件可以运行在这个操作系统上。&lt;/p&gt;
&lt;p&gt;然而有一个问题，就是锂电池的使用与寿命，虽说是闲置、淘汰了的Android设备，但始终插着电源线充电显然不妥。&lt;/p&gt;
&lt;p&gt;比较理想的方式是，建立一个自动化的充电机制：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Android设备始终插着电源线，但并不是始终充电。当电池电量低（低于20%）时，能够自动启动充电，而电量高（超过90%）时，自动关闭充电。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最初使用了一个&lt;a href=&quot;https://www.mi.com/mj-socket/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;米家智能插座 基础版&lt;/a&gt;来实现。&lt;/p&gt;
&lt;p&gt;这里吐槽一下&lt;a href=&quot;https://home.mi.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;米家&lt;/a&gt;app，触发插座开关的可选项实在是太少，也没有提供公开的API。&lt;/p&gt;
&lt;p&gt;无奈已经买了硬件，自己挖的坑，自己填。&lt;/p&gt;
&lt;p&gt;过程不细说了（如果有感兴趣的读者留言，可以考虑另外写一篇），结果是：&lt;/p&gt;
&lt;p&gt;使用Android下的busybox中的crontab，周期性的检查 &lt;code&gt;/sys/class/power_supply/battery&lt;/code&gt; 下的电量信息。&lt;/p&gt;
&lt;p&gt;通过shell脚本，判断电量后，使用 &lt;code&gt;adb input keyevent&lt;/code&gt; 和 &lt;code&gt;adb input swipe&lt;/code&gt; 模拟屏幕操作。&lt;/p&gt;
&lt;p&gt;使用米家app，把智能插座usb口的开关，放两个快捷方式在Android的桌面上，通过模拟屏幕操作点击。&lt;/p&gt;
&lt;p&gt;如此实现了自动化充电的机制，这时可以把Android设备视作一个linux server，或者说，更像是一个Raspberry Pi，可以放飞自我了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="智能家庭" scheme="https://mu4yu3.github.io/tags/%E6%99%BA%E8%83%BD%E5%AE%B6%E5%BA%AD/"/>
    
      <category term="smart home" scheme="https://mu4yu3.github.io/tags/smart-home/"/>
    
      <category term="Home Assistant" scheme="https://mu4yu3.github.io/tags/Home-Assistant/"/>
    
      <category term="homebridge" scheme="https://mu4yu3.github.io/tags/homebridge/"/>
    
      <category term="HomeKit" scheme="https://mu4yu3.github.io/tags/HomeKit/"/>
    
  </entry>
  
  <entry>
    <title>USB redirection 的实验记录</title>
    <link href="https://mu4yu3.github.io/2018/01/10/usb_redirection/"/>
    <id>https://mu4yu3.github.io/2018/01/10/usb_redirection/</id>
    <published>2018-01-10T05:18:13.000Z</published>
    <updated>2018-01-15T05:05:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近遇到这样一个需求：</p><p>某USB设备（不限种类），物理上插在某A机器上，需要在某B系统中使用，而这个B系统，运行在某台服务器C的虚拟化环境中。<br>A、B、C系统可以通过网络相互访问。</p><p>这是前提。</p><p>再具体一下，A的系统可以不限定windows或者linux，B系统限定为windows，版本限定在7或更高版本。<br>另外，C系统所用虚拟化技术不限，可以考虑kvm、或者vmware、甚至virtualbox也可以。</p><p>这是现实。</p><p>众多的解决方案中，有不少商业方案，毕竟花钱可以解决大多数问题。</p><p>本文描述了开源方案。</p><p>想要直接得到答案的读者，可以绕过 <strong>弯路</strong> ，去 <strong>直路</strong> 看结果。</p><a id="more"></a><h2 id="弯路"><a href="#弯路" class="headerlink" title="弯路"></a>弯路</h2><p>通过google，找到了一个名叫 <a href="http://usbip.sourceforge.net" target="_blank" rel="noopener">USB/IP</a> 的开源项目。</p><p>看文档，它包括了linux的server和client端，甚至还包括一个windows版的client端，一切看上去都那么符合我们的需求。</p><p>可是实际测试的时候，发生了问题。</p><p>server端使用了fedora 26自带软件仓库的usbip。</p><p>client端使用了<a href="https://sourceforge.net/projects/usbip/files/usbip_windows/" target="_blank" rel="noopener">sourceforge提供的二进制包</a>。</p><p>连接报错。</p><h3 id="第1次尝试"><a href="#第1次尝试" class="headerlink" title="第1次尝试"></a>第1次尝试</h3><p>这篇<a href="https://sourceforge.net/p/usbip/discussion/418507/thread/7ff86875/" target="_blank" rel="noopener">帖子</a>里描述了类似的报错信息。</p><p>按照2楼的说法，修改了源码，重新编译（这里有个坑，看源码以为可以使用gcc编译，最终使用virtual studio 2010才编译成功）。</p><p>重新编译以后，使用 <code>usbip list</code> 命令可以看到server端bind的设备，但使用 <code>usbip attach</code> 的时候依然报错。</p><p>至此，基本放弃了windows端client的思路。</p><h3 id="第2次尝试"><a href="#第2次尝试" class="headerlink" title="第2次尝试"></a>第2次尝试</h3><p>kvm支持USB passthrough，直接将本机的usb设备，映射到虚拟机中。</p><p>所以问题可以转化为：在服务器中使用usbip的client端，先将usb设备映射到服务器本地，再通过kvm映射到虚拟机中。</p><p>这样可以绕过windows端的client问题，只要linux版的usbip可以使用就ok。（实际上，不只是这样就可以，还有一个隐患问题，后面会遇到。）</p><p>使用了2台笔记本做实验，两端分别使用了fedora的25、26版本，安装自带软件仓库的usbip，<code>dnf update</code> 到最新。</p><p>结果失败，<code>usbip list</code> 命令可以看到server端bind的设备，但使用 <code>usbip attach</code> 的时候报错。</p><p>尝试将一台fedora从25升级到26，保持server和client两端都是26，还是报错。</p><p>尝试将2台系统更换到ubuntu 16.04，报错。</p><p>尝试将2台系统更换到ubuntu 12.04，报错。</p><p>这真是见鬼了，还是第一次遇到发行版本自带的软件有这种bug的情况。</p><h3 id="第3次尝试"><a href="#第3次尝试" class="headerlink" title="第3次尝试"></a>第3次尝试</h3><p>还是回到源码里面找原因，<a href="https://sourceforge.net/p/usbip/git-windows/ci/master/tree/" target="_blank" rel="noopener">sourceforge上的源码</a>在2011年就停止更新了。</p><p>这个项目后续难道没人再维护了么？</p><p>仔细阅读了<a href="http://usbip.sourceforge.net" target="_blank" rel="noopener">项目主页</a>，有这样一段话：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">For Linux, the source code of usbip was merged into the staging tree, and finally has</span><br><span class="line">been moved to the mainline since Linux-3.17. Development is ongoing in the kernel</span><br><span class="line">community, not here. Linux distributions will provide binary packages of usbip. Just for</span><br><span class="line">historical records, the project page keeps old download files of the Linux version. Do</span><br><span class="line">not use them.</span><br></pre></td></tr></table></figure></p><p>原来如此，既然发行版本里面自带的usbip不好用，那么就去linux的源码里面找。</p><p>果然，在<a href="https://github.com/torvalds/linux" target="_blank" rel="noopener">linux的源码</a> <code>tools/usb/usbip</code> 目录下，找到了usbip的<a href="https://github.com/torvalds/linux/tree/master/tools/usb/usbip" target="_blank" rel="noopener">源代码</a>。</p><p>这时候再来看，当前fedora26，<code>dnf update</code> 到最新，自带的内核版本为 <code>4.14.11-200</code> ，而usbip的版本为 <code>4.9.9</code>。于是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/torvalds/linux.git</span><br></pre></td></tr></table></figure></p><p>敲完这个命令，就去睡觉。等一觉醒来，已经下好了，有3个G大小。</p><p>然后找到 <code>4.14</code> 版本的内核（对应fedora26，其他发行版本可能不一样）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout v4.14</span><br></pre></td></tr></table></figure></p><p>果然不愧是3G的git，在其他git库里面瞬间执行的命令，这里要等待30秒。</p><p>在 <code>tools/usb/usbip</code> 目录下，找到源码，按照readme的说明，编译源码。</p><p>这里单独使用了一个docker的容器，来进行编译工作。下载了fedora的官方镜像。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull fedora:26</span><br></pre></td></tr></table></figure></p><p>启动容器后，先安装编译环境：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf group install &quot;C Development Tools and Libraries&quot; -y</span><br></pre></td></tr></table></figure></p><p>将源码放到 <code>/opt/usbip</code> 目录下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./autogen.sh</span><br><span class="line">./configure</span><br></pre></td></tr></table></figure></p><p>这一步会报错，有缺少的库文件，通过dnf查找库文件的安装包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf provides /usr/include/libudev.h</span><br></pre></td></tr></table></figure></p><p>安装缺少的包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf install file systemd-devel -y</span><br></pre></td></tr></table></figure></p><p>再一次执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br><span class="line">./make</span><br></pre></td></tr></table></figure></p><p>成功后在 <code>/opt/usbip/src</code> 目录下可以看到 <code>usbip</code> 和 <code>usbipd</code> 这2个可执行文件。</p><p>把 <code>/opt/usbip</code> 整个目录 <code>scp</code> 到server端和client端的fedora系统里，放置在同样的目录下。</p><p>在server端运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/usbip/src</span><br><span class="line">modprobe usbip-core</span><br><span class="line">modprobe usbip-host</span><br><span class="line">./usbipd -D</span><br><span class="line">./usbip list -l</span><br><span class="line">./usbip bind --busid 2-1</span><br></pre></td></tr></table></figure></p><p>在client端运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/usbip/src</span><br><span class="line">modprobe usbip-core</span><br><span class="line">modprobe vhci-hcd</span><br><span class="line">./usbip list --remote 10.0.0.1</span><br><span class="line">./usbip attach --remote 10.0.0.1 --busid 2-1</span><br></pre></td></tr></table></figure></p><p>实验里映射的是一个usb的键鼠套装，至此，已经可以控制client端的操作。从linux到linux的usbip已经完成验证。</p><p>想要解除，可以在client端运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./usbip port</span><br><span class="line">./usbip detach --port 0</span><br></pre></td></tr></table></figure></p><p>在server端运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./usbip unbind --busid 2-1</span><br></pre></td></tr></table></figure></p><h3 id="埋伏的隐患"><a href="#埋伏的隐患" class="headerlink" title="埋伏的隐患"></a>埋伏的隐患</h3><p>还记得之前提到的隐患么，它出现在这里。</p><p>当把client端的usb设备，通过KVM的USB passthrough，映射到虚拟机中。</p><p>配置操作是可以完成的，然而它并不生效。</p><p>无论是配置后，启动虚拟机；或者先启动虚拟机，再添加USB设备，在虚拟系统里，它都不生效。</p><p>并且一旦虚拟机重启，usb设备在host系统也消失了。需要重启usbip的server和client端，才能重新映射过来。</p><p>换言之，无法满足最终需求。</p><h2 id="直路"><a href="#直路" class="headerlink" title="直路"></a>直路</h2><p>在使用kvm管理工具 <code>virt-manager</code> 的过程中，通过USB passthrough，映射本地usb设备。意外发现有usb重定向选项。</p><p>在usb重定向的类型选择中，除了Spice通道，还有TCP的方式，可以填写host和port。</p><p>顺着这个思路Google，找到名为 <code>usbredir-server</code> 的软件包。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf install usbredir-server -y</span><br></pre></td></tr></table></figure></p><p>通过观察usb设备前的 <usbbus-usbaddr|vendorid:prodid> 代码，类似 xxxx:xxxx 的形式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lsusb</span><br><span class="line">usbredirserver -p 55555 -v 3 xxxx:xxxx</span><br></pre></td></tr></table></figure></usbbus-usbaddr|vendorid:prodid></p><p>端口可以自定义。<br>verbosity level（-v）级别从0-5，0:Silent 1:Errors 2:Warnings 3:Info 4:Debug 5:Debug++。</p><p>这将把对应的usb设备映射到网上。可以通过 <code>netstat</code> 命令检查。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -altunp | grep &quot;usbredirserver&quot;</span><br></pre></td></tr></table></figure></p><p>client端，在kvm中配置（可以在 <code>virt-manager</code> 中设置，也可以直接修改域配置xml文件）TCP的host和port。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;redirdev bus=&apos;usb&apos; type=&apos;tcp&apos;&gt;</span><br><span class="line">  &lt;source mode=&apos;connect&apos; host=&apos;10.0.0.1&apos; service=&apos;55555&apos;/&gt;</span><br><span class="line">  &lt;protocol type=&apos;raw&apos;/&gt;</span><br><span class="line">  &lt;address type=&apos;usb&apos; bus=&apos;0&apos; port=&apos;9&apos;/&gt;</span><br><span class="line">&lt;/redirdev&gt;</span><br></pre></td></tr></table></figure></p><p>启动虚拟机，测试生效。</p><h3 id="hot-plug-redirdev-device"><a href="#hot-plug-redirdev-device" class="headerlink" title="hot-plug redirdev device"></a>hot-plug redirdev device</h3><p>关于重定向设备的热插拔，这里使用了 <code>virsh</code> 命令</p><p>如果在上一个步骤中没有修改配置文件，也就是在虚拟机启动时，尚未添加重定向设备，可以将上述文件内容单独保存为一个xml文件。</p><p>假设这个文件保存为 <code>usb_redir.xml</code>，启动的虚拟机，名称为 <code>test_vm</code>。</p><p>执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virsh attach-device test_vm usb_redir.xml --live</span><br></pre></td></tr></table></figure></p><p>可以成功附加远程设备。</p><p>而使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virsh detach-device test_vm usb_redir.xml --live</span><br></pre></td></tr></table></figure></p><p>则会报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error: Failed to detach device from usb_redir.xml</span><br><span class="line">error: Operation not supported: live detach of device &apos;redirdev&apos; is not supported</span><br></pre></td></tr></table></figure></p><p>看来在当前的 <code>virsh</code> 版本中， <code>redirdev</code> 设备还不支持hot unplugging。</p><p>好消息是：已经有人注意到类似问题并<a href="https://gitlab.com/libvirt/libvirt/commit/91a3234f3a218a581ede975164e66ce7b0347f4c" target="_blank" rel="noopener">提交了源码修改</a>。</p><h2 id="多说两句"><a href="#多说两句" class="headerlink" title="多说两句"></a>多说两句</h2><p>其实usb的重定向，也可以使用 <code>M$</code> 的RemoteFX，或者spice的远程来解决。</p><p>但这2个方案似乎都需要客户端保持远程连接，usb的重定向才能生效，一旦远程连接断开，usb的重定向也会断开。</p><p>所以并不在考虑的范围内。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近遇到这样一个需求：&lt;/p&gt;
&lt;p&gt;某USB设备（不限种类），物理上插在某A机器上，需要在某B系统中使用，而这个B系统，运行在某台服务器C的虚拟化环境中。&lt;br&gt;A、B、C系统可以通过网络相互访问。&lt;/p&gt;
&lt;p&gt;这是前提。&lt;/p&gt;
&lt;p&gt;再具体一下，A的系统可以不限定windows或者linux，B系统限定为windows，版本限定在7或更高版本。&lt;br&gt;另外，C系统所用虚拟化技术不限，可以考虑kvm、或者vmware、甚至virtualbox也可以。&lt;/p&gt;
&lt;p&gt;这是现实。&lt;/p&gt;
&lt;p&gt;众多的解决方案中，有不少商业方案，毕竟花钱可以解决大多数问题。&lt;/p&gt;
&lt;p&gt;本文描述了开源方案。&lt;/p&gt;
&lt;p&gt;想要直接得到答案的读者，可以绕过 &lt;strong&gt;弯路&lt;/strong&gt; ，去 &lt;strong&gt;直路&lt;/strong&gt; 看结果。&lt;/p&gt;
    
    </summary>
    
    
      <category term="usb重定向" scheme="https://mu4yu3.github.io/tags/usb%E9%87%8D%E5%AE%9A%E5%90%91/"/>
    
      <category term="usb over ip" scheme="https://mu4yu3.github.io/tags/usb-over-ip/"/>
    
      <category term="usbip" scheme="https://mu4yu3.github.io/tags/usbip/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://mu4yu3.github.io/2018/01/01/hello-world/"/>
    <id>https://mu4yu3.github.io/2018/01/01/hello-world/</id>
    <published>2018-01-01T13:45:23.000Z</published>
    <updated>2018-01-12T16:20:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>多少年了，没有再写过blog。</p><p>当年曾经在<code>M$</code>的<a href="https://zh.wikipedia.org/wiki/Windows_Live_Spaces" target="_blank" rel="noopener">MSN Spaces</a>写过博客。</p><p>后来msn spaces停止服务了，将blog迁移到sina，从那时候开始就很少写了。</p><p>其实也不是写的少，只是不再放在网络上了。</p><h2 id="现在"><a href="#现在" class="headerlink" title="现在"></a>现在</h2><p>最近使用github逐渐变多，对于开源、共享的想法也越来越多。</p><p>想要写点东西的念头又开始萌发。</p><p>“写个blog吧”，对自己说。</p><a id="more"></a><h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><p>其实写blog也有很多选择。</p><p>继续使用sina的也算；租一个vps，架一个WordPress也可以；或者另找一个第三方托管，比如Blogger。</p><p>但一来需要考虑到在大陆能访问，二来估计访问量较小，三来考虑未来迁移较方便，四来希望能有更多的控制权。</p><p>最终选择了<a href="https://pages.github.com" target="_blank" rel="noopener">GitHub Pages</a>，作为blog的托管。</p><p>选择了使用<a href="https://github.com/hexojs/hexo" target="_blank" rel="noopener">hexo</a>，作为blog框架。</p><p>选择了<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">next</a>，作为blog主题。</p><h2 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h2><p>其实这个blog能写多久、写些什么、将来会怎么样，都不太清楚。</p><p>也许只有这一篇，后面就没有了。</p><p>也许会写一些技术相关的文档，也许会写一些自己的感悟。</p><p>也许将来这里会成为一个交流的节点，也许这里只是自己的后花园。</p><p>但无论将来怎样，其实现在做什么才是更重要，更有意义的事儿，不是么？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;多少年了，没有再写过blog。&lt;/p&gt;
&lt;p&gt;当年曾经在&lt;code&gt;M$&lt;/code&gt;的&lt;a href=&quot;https://zh.wikipedia.org/wiki/Windows_Live_Spaces&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MSN Spaces&lt;/a&gt;写过博客。&lt;/p&gt;
&lt;p&gt;后来msn spaces停止服务了，将blog迁移到sina，从那时候开始就很少写了。&lt;/p&gt;
&lt;p&gt;其实也不是写的少，只是不再放在网络上了。&lt;/p&gt;
&lt;h2 id=&quot;现在&quot;&gt;&lt;a href=&quot;#现在&quot; class=&quot;headerlink&quot; title=&quot;现在&quot;&gt;&lt;/a&gt;现在&lt;/h2&gt;&lt;p&gt;最近使用github逐渐变多，对于开源、共享的想法也越来越多。&lt;/p&gt;
&lt;p&gt;想要写点东西的念头又开始萌发。&lt;/p&gt;
&lt;p&gt;“写个blog吧”，对自己说。&lt;/p&gt;
    
    </summary>
    
    
      <category term="心情" scheme="https://mu4yu3.github.io/tags/%E5%BF%83%E6%83%85/"/>
    
      <category term="杂谈" scheme="https://mu4yu3.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
</feed>
