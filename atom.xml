<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lich&#39;s Blog</title>
  
  <subtitle>Just do IT.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://mu4yu3.github.io/"/>
  <updated>2018-06-15T15:21:53.000Z</updated>
  <id>https://mu4yu3.github.io/</id>
  
  <author>
    <name>Lich</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>百万摇号 + 统计学 = 购房摇号合理质疑（系列1）</title>
    <link href="https://mu4yu3.github.io/2018/06/13/nanjing_jiazhaoye/"/>
    <id>https://mu4yu3.github.io/2018/06/13/nanjing_jiazhaoye/</id>
    <published>2018-06-13T15:03:39.000Z</published>
    <updated>2018-06-15T15:21:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>最近南京佳兆业开盘，在<a href="http://njnotary.cn/staticfiles/wwwnews/20180613/1187.html" target="_blank" rel="noopener">南京公证处摇号</a>。12524个报名，摇475个房源，约3.8%中签率。</p><p><strong>利益相关</strong>，本文作者也参与了本次摇号，结果排在半数之后，买房无缘。</p><p>本来此事已经了结，但一个想法开始在脑海中萦绕：“就算是公证处的摇号，一定公平公正么？”</p><p>用数学的语言来说：<strong><em>这次的摇号结果，是真随机的么</em></strong> ？</p><p>本着科学 <strong>怀疑一切</strong> 的精神，开始 <strong>大胆假设，小心求证</strong> 。</p><p>大胆假设摇号有内幕，有内定号，那么这个摇号结果，和 <strong>真随机</strong> 的结果会有什么差异？</p><p>于是就有了本文。</p><a id="more"></a><h2 id="太长不看版"><a href="#太长不看版" class="headerlink" title="太长不看版"></a>太长不看版</h2><p>通过数学的方法，通过方差值，可以观察一组数据的<a href="https://zh.wikipedia.org/wiki/随机性" target="_blank" rel="noopener">随机性</a>。</p><p>一个真随机组合，会符合一定的<a href="https://zh.wikipedia.org/wiki/概率分布" target="_blank" rel="noopener">概率分布</a>。相反，如果不符合概率分布，则有很大可能性，是<a href="https://zh.wikipedia.org/wiki/伪随机性" target="_blank" rel="noopener">伪随机</a>组合。</p><p>请注意：在摇号这件事情上，<strong>伪随机</strong> 不完全等于 <strong>有人为干预</strong> 更不完全等于 <strong>有内幕交易</strong>。</p><p>比如程序设计bug，算法bug、硬件bug，都有可能造成 <strong>伪随机</strong>。</p><p>概率分布通常符合正态分布，可以用一个简单、粗暴的方式，得出近似值。就是多次尝试，比如，尝试 <strong>一百万次</strong> ！</p><p>那么根据本次摇号的随机性（方差值），可能会有2种情况：</p><ol><li>如果在这个概率分布区间内，我们认为 <strong>“本次摇号从概率上说，是有可能发生的”</strong></li><li>如果不在这个区间内，我们认为 <strong>“本次摇号从概率上说，几乎不可能发生”</strong> 或者更准确的说法是，<strong>“本次摇号从概率上说，发生的可能性低于百万分之一”</strong></li></ol><p>其中，如果是第1种情况，我们还可以将再具体分为3种情况：</p><ol><li>向着正态分布的右侧，发生可能性小，方差越大，数据的离散程度越大， <strong>伪随机</strong> 的可能性越大，具体到摇号这件事上，更趋向于”不公平”。</li><li>中值区域，是最有可能发生的区域。</li><li>向着正态分布的左侧，发生可能性小，方差越小，数据越稳定，<strong>伪随机</strong> 的可能性也越大，但具体到摇号这件事情上，因为趋向于更“公平”，反而人为干预可能性不高。</li></ol><p>那么大家可以猜一下，本次摇号的随机性，在 <strong>真随机的概率分布</strong> 中，会落在那个区域内？</p><p>先说结果：</p><blockquote><ul><li>本次摇号，落在了正态分布的极右侧，也就是1.1的区域</li><li>本次摇号，在 <strong>真随机</strong> 中发生的总体概率大约为3.2‰，非常低。远低于本次摇号的中签率（约3.8%）</li></ul></blockquote><p>特别提示：前者是千分之3.2，后者是百分之3.8</p><p>真随机可能性极小 + 伪随机可能性大 + 趋向于“不公平” = 文章标题上所写的 <strong>合理质疑</strong>，热烈欢迎更有能力的人士指正错误。</p><p>计算和过程可以看下面的章节。本文所有使用的工具、程序、算法，均开源。有兴趣的读者可以重复实验。</p><p>不耐烦看数学过程的，可以直接拖到最后看图，有图有真相。</p><h2 id="百万摇号实验过程"><a href="#百万摇号实验过程" class="headerlink" title="百万摇号实验过程"></a>百万摇号实验过程</h2><h3 id="数据来源"><a href="#数据来源" class="headerlink" title="数据来源"></a>数据来源</h3><p>目前在南京公证处官网上，有<a href="http://njnotary.cn/staticfiles/wwwnews/20180613/1188.html" target="_blank" rel="noopener">结果公示</a>。</p><p>有附件<a href="http://njnotary.cn/staticfiles/wwwnews/20180613/1188.html" target="_blank" rel="noopener">《城市水岸花园15幢、16幢、17幢商品住房选房顺序号公证摇号结果.pdf》</a>供下载。</p><p>以下分析全部基于该pdf文档。提取文件特征信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">du -b 180613_003.pdf</span><br><span class="line">395127  180613_003.pdf</span><br><span class="line"></span><br><span class="line">md5sum 180613_003.pdf</span><br><span class="line">5ae279c4d816ee53717098adb55fea87</span><br><span class="line"></span><br><span class="line">sha1sum 180613_003.pdf</span><br><span class="line">b76af85a83c05e7a263fb942ae84745f5c26d376</span><br><span class="line"></span><br><span class="line">sha256sum 180613_003.pdf</span><br><span class="line">430d13d91d31c4f3d0e1281f3f3749caefdcdf21fd22535aafa7d81d78a84b87</span><br></pre></td></tr></table></figure><h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><p>本次摇号，一共有12524个报名，最后摇出12524个号。</p><p>大胆假设，有内幕，我要求内定号，那么需要做到：</p><ol><li>将我的号，放在475内，保证可以买到房。</li><li>将我的号，尽可能提前，这样可以保证选到心仪的户型。</li><li>在我以后的号码无所谓，你们随便摇，开心就好。</li></ol><p>所以前475号内，可能存在人工选择的报名号，而不是纯随机摇出的报名号。</p><p>而人工选择的报名号，较大概率导致离散程度变大，从而导致方差变大。</p><p>之所以说是较大概率，是因为如果在报名的时候，就将内选号，随机分布在12524个号码中间，可能会干扰结果，使离散程度趋于正常。</p><p>12524等于31乘以404，而404很接近本次房源数475。</p><p>为了统计方便（为了偷懒），将数据分为31组，第1组数据从1至404，第2组从405至808，以此类推（完全可以采用其他方式统计，欢迎读者尝试，并反馈结果）。</p><p>那么12524个报名者。可以被分到31个组里面。</p><p>把摇号也分为31组，这样可以形成一个矩阵。理论上，矩阵中的每个单元，都应该均匀的分布着这31组的报名者，像这样：</p><p><img src="/images/variance_matrix.png" alt="matrix"></p><p>（本次佳兆业摇号真实矩阵，竖列表示摇号组，横排表示报名组，左上角第一格，表示第1组摇号中，有18人是属于第1组报名）</p><blockquote><p>需要注意的是，摇号是从1排序到12524，报名号是从1至12598号，中间无重复，但不连续，有空档。猜测空档是因为不符合资质剔除的报名者。</p><p>制作矩阵时，会将报名号排序后，重新给予1至12524的新号码，用于统计。</p></blockquote><p>在这个矩阵中，第一横排，也就是第1组摇号，31个报名组的分布情况，是最值得关注的。</p><p>如果这个横排的离散程度（方差值），超过了 <strong>真随机</strong> 的概率区间，（比如极端情况：都是来自同一个组的），那么基本可以判定是 <strong>伪随机</strong>。</p><p>这方差值是：<strong><em>20.740894901144642</em></strong>，请记住这个值，后面还会用到。</p><p>接下来，就是百万摇号登场。</p><h3 id="人生苦短，我用python"><a href="#人生苦短，我用python" class="headerlink" title="人生苦短，我用python"></a>人生苦短，我用python</h3><p>以下开放源码。</p><h4 id="首先设计一个-真随机-的模拟摇号程序"><a href="#首先设计一个-真随机-的模拟摇号程序" class="headerlink" title="首先设计一个 真随机 的模拟摇号程序"></a>首先设计一个 <strong>真随机</strong> 的模拟摇号程序</h4><p>lottery.py<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"></span><br><span class="line">import os</span><br><span class="line">import random</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    base_path=os.path.abspath(&apos;.&apos;)</span><br><span class="line">    raw_data_path=os.path.join( base_path, &apos;raw_data&apos;)</span><br><span class="line"></span><br><span class="line">    if not os.path.exists(raw_data_path):</span><br><span class="line">        os.mkdir(raw_data_path)</span><br><span class="line"></span><br><span class="line">    for num in range(1,1000001):</span><br><span class="line">        with open(raw_data_path + &apos;/&apos; + str(num) + &apos;.csv&apos;, &apos;w&apos;) as csv_file:</span><br><span class="line">            pass</span><br><span class="line"></span><br><span class="line">        with open(raw_data_path + &apos;/&apos; + str(num) + &apos;.csv&apos;, &apos;a&apos;) as csv_file:</span><br><span class="line">            a=list(range(1,12525))</span><br><span class="line">            for x in range(1,12525):</span><br><span class="line">                csv_file.write(str(x))</span><br><span class="line">                csv_file.write(&apos;,&apos;)</span><br><span class="line">                b=random.randrange(0,len(a),1)</span><br><span class="line">                csv_file.write(str(a[b]))</span><br><span class="line">                csv_file.write(&apos;\n&apos;)</span><br><span class="line">                a.pop(b)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></p><p>这个程序，将在当前目录下，生成一个子目录<code>raw_data</code>，在子目录里面，生成1.csv、2.csv……1000000.csv，一共百万个文档。</p><p>每个文档中，存放了1次模拟摇号的结果。</p><p>需要注意5点：</p><ol><li>生成时间很长，通常需要十几个小时（看计算机配置）</li><li>占用123G硬盘空间</li><li>不同的文件系统，支持的子文件数量是不同的。比如ext3默认是32000，显然是不够的。ext4可以支持。</li><li>即便支持，也不要随便去子目录<code>raw_data</code>操作，以免卡顿（不要问我怎么知道的）</li><li>可以通过命令<code>find ./raw_data/* -type f | wc -l</code>观察生成进度，<code>ls</code>命令不行（不要问我怎么知道的）</li></ol><h4 id="第二个程序是统计，也就是生成上面所说的矩阵"><a href="#第二个程序是统计，也就是生成上面所说的矩阵" class="headerlink" title="第二个程序是统计，也就是生成上面所说的矩阵"></a>第二个程序是统计，也就是生成上面所说的矩阵</h4><p>statistics.py<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"></span><br><span class="line">import os</span><br><span class="line">import csv</span><br><span class="line">import numpy</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    base_path=os.path.abspath(&apos;.&apos;)</span><br><span class="line">    raw_data_path=os.path.join( base_path, &apos;raw_data&apos;)</span><br><span class="line">    statistical_data_path=os.path.join( base_path, &apos;statistical_data&apos;)</span><br><span class="line"></span><br><span class="line">    if not os.path.exists(raw_data_path):</span><br><span class="line">        exit(1)</span><br><span class="line">    if not os.path.exists(statistical_data_path):</span><br><span class="line">        os.mkdir(statistical_data_path)</span><br><span class="line"></span><br><span class="line">    for num in range(1,1000001):</span><br><span class="line">        lis=[]</span><br><span class="line"></span><br><span class="line">        with open(raw_data_path + &apos;/&apos; + str(num) + &apos;.csv&apos;, &apos;r&apos;) as csv_file:</span><br><span class="line">            reader = csv.reader(csv_file)</span><br><span class="line">            for row in reader:</span><br><span class="line">                lis.append(row)</span><br><span class="line"></span><br><span class="line">        mat=numpy.zeros((31, 31), dtype=numpy.int)</span><br><span class="line"></span><br><span class="line">        for x,y in lis:</span><br><span class="line">            p=(int(x)-1)//404</span><br><span class="line">            q=(int(y)-1)//404</span><br><span class="line">            mat[p][q]=mat[p][q]+1</span><br><span class="line"></span><br><span class="line">        numpy.savetxt(statistical_data_path + &apos;/&apos; + str(num) + &apos;.csv&apos;, mat, delimiter = &apos;,&apos; ,fmt=&apos;%s&apos;,newline=&apos;\n&apos;)  </span><br><span class="line"></span><br><span class="line">        with open(base_path + &apos;/&apos; + &apos;variance.csv&apos;, &apos;a&apos;) as csv_file:</span><br><span class="line">            csv_file.write(str(mat[0].var()))</span><br><span class="line">            csv_file.write(&apos;\n&apos;)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></p><p>这个程序，将在当前目录下，生成一个子目录<code>statistical_data</code>，在子目录里面，生成1.csv、2.csv……1000000.csv，一共百万个文档。</p><p>每个文档中，存放了1次模拟摇号所生成的矩阵。</p><p>另外，还有一个附加功能，就是在当前目录下生成了 <code>variance.csv</code> 文件。</p><p>这个文件保存了每次摇号矩阵第一行的方差值，一共有百万条记录。</p><p>提示：如果不需要复验，其实可以将程序1、2合并成一个程序，省略中间环节，直接生成 <code>variance.csv</code> 文件，可以大大加速。</p><h4 id="第三个程序根据-variance-csv-显示方差概率分布"><a href="#第三个程序根据-variance-csv-显示方差概率分布" class="headerlink" title="第三个程序根据 variance.csv 显示方差概率分布"></a>第三个程序根据 <code>variance.csv</code> 显示方差概率分布</h4><p>normal.py<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"></span><br><span class="line">import os</span><br><span class="line">import numpy</span><br><span class="line">import scipy</span><br><span class="line">from scipy import stats</span><br><span class="line">import matplotlib</span><br><span class="line">matplotlib.use(&apos;Agg&apos;)</span><br><span class="line">from matplotlib import pyplot</span><br><span class="line">from matplotlib.font_manager import FontProperties</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line"></span><br><span class="line">    base_path=os.path.abspath(&apos;.&apos;)</span><br><span class="line"></span><br><span class="line">    if not os.path.isfile(base_path + &apos;/&apos; + &apos;variance.csv&apos; ):</span><br><span class="line">        exit(1)</span><br><span class="line"></span><br><span class="line">    lis=[]</span><br><span class="line"></span><br><span class="line">    with open(base_path + &apos;/&apos; + &apos;variance.csv&apos;, &apos;r&apos;) as csv_file:</span><br><span class="line">        for row in csv_file.readlines():</span><br><span class="line">            lis.append(float(row))</span><br><span class="line"></span><br><span class="line">    mean=sum(lis)/len(lis)</span><br><span class="line">    stdev=numpy.std(lis)</span><br><span class="line">    lis_range=(min(lis), max(lis))</span><br><span class="line">    x=numpy.linspace(lis_range[0], lis_range[1], 100)</span><br><span class="line">    normal=stats.norm(mean, stdev)</span><br><span class="line"></span><br><span class="line">    pyplot.rcParams[&apos;font.sans-serif&apos;] = &apos;SimHei&apos;</span><br><span class="line">    pyplot.rcParams[&apos;axes.unicode_minus&apos;] = False</span><br><span class="line"></span><br><span class="line">    pyplot.hist(lis, density=True ,bins=100, range=(min(lis)-1,max(lis)+1), color=&apos;green&apos;, label=u&apos;百万次模拟摇号&apos;, histtype=&apos;stepfilled&apos;)</span><br><span class="line">    pyplot.axvline(x=mean, color=&apos;yellow&apos;, linewidth=2)</span><br><span class="line"></span><br><span class="line">    t=20.740894901144642</span><br><span class="line">    pyplot.annotate(u&apos;本次摇号所在位置&apos;,xy=(t, normal.pdf(t)),xycoords=&apos;data&apos;,xytext=(+10, +30), textcoords=&apos;offset points&apos;, fontsize=16, arrowprops=dict(arrowstyle=&quot;-&gt;&quot;, connectionstyle=&quot;arc3,rad=.2&quot;))</span><br><span class="line"></span><br><span class="line">    print(normal.pdf(t))</span><br><span class="line">    print(normal.cdf(t))</span><br><span class="line"></span><br><span class="line">    pyplot.plot(x, normal.pdf(x), &apos;--&apos;, label=u&apos;标准正态分布&apos;, color=&apos;red&apos;, linewidth=2)</span><br><span class="line">    pyplot.xlabel(u&apos;前404号方差分布&apos;)</span><br><span class="line">    pyplot.title(u&apos;百万次模拟摇号，前404号方差分布图&apos;)</span><br><span class="line">    pyplot.legend()</span><br><span class="line">    pyplot.savefig(&quot;normal.png&quot;)</span><br><span class="line">    pyplot.close()</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></p><p>这个程序使用了 <code>matplotlib</code> 的绘图功能，画出了下面这个分布图：</p><p><img src="\images\variance_normal.png" alt="normal"></p><p>黄色的竖线表示中值，红色曲线是标准正态分布，绿色是实际的分布，可以看出绿色近似拟合红色曲线。</p><p>可以清晰的看到，本次摇号所在的位置。</p><p>按照正态分布公式计算，本次摇号的pdf（概率密度函数）是：0.003189864384789601 ，而cdf（累计分布函数）是：0.9966758306307064</p><p>这表示：</p><ul><li>本次摇号，落在了正态分布的极右侧</li><li>在 <strong>真随机</strong> 摇号中，出现本次摇号情况的概率约为3.2‰，非常低。远低于本次摇号的中签率（约3.8%）</li><li>在 <strong>真随机</strong> 摇号中，出现本次摇号情况，再加上比本地摇号更“不公平”的情况，累计的可能性大约为3.4‰</li></ul><p>再次强调一下：在摇号这件事情上，<strong>伪随机</strong> 不完全等于 <strong>有人为干预</strong> 更不完全等于 <strong>有内幕交易</strong>。</p><p>本文在 <strong>合理质疑</strong> 摇号的 <strong>随机性</strong>。不针对 <strong>是否有内幕</strong> 提出任何质疑。</p><h2 id="以为这就结束了？其实还没有。"><a href="#以为这就结束了？其实还没有。" class="headerlink" title="以为这就结束了？其实还没有。"></a>以为这就结束了？其实还没有。</h2><p>未完待续……</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;最近南京佳兆业开盘，在&lt;a href=&quot;http://njnotary.cn/staticfiles/wwwnews/20180613/1187.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;南京公证处摇号&lt;/a&gt;。12524个报名，摇475个房源，约3.8%中签率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;利益相关&lt;/strong&gt;，本文作者也参与了本次摇号，结果排在半数之后，买房无缘。&lt;/p&gt;
&lt;p&gt;本来此事已经了结，但一个想法开始在脑海中萦绕：“就算是公证处的摇号，一定公平公正么？”&lt;/p&gt;
&lt;p&gt;用数学的语言来说：&lt;strong&gt;&lt;em&gt;这次的摇号结果，是真随机的么&lt;/em&gt;&lt;/strong&gt; ？&lt;/p&gt;
&lt;p&gt;本着科学 &lt;strong&gt;怀疑一切&lt;/strong&gt; 的精神，开始 &lt;strong&gt;大胆假设，小心求证&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;大胆假设摇号有内幕，有内定号，那么这个摇号结果，和 &lt;strong&gt;真随机&lt;/strong&gt; 的结果会有什么差异？&lt;/p&gt;
&lt;p&gt;于是就有了本文。&lt;/p&gt;
    
    </summary>
    
    
      <category term="摇号" scheme="https://mu4yu3.github.io/tags/%E6%91%87%E5%8F%B7/"/>
    
      <category term="随机性" scheme="https://mu4yu3.github.io/tags/%E9%9A%8F%E6%9C%BA%E6%80%A7/"/>
    
      <category term="方差" scheme="https://mu4yu3.github.io/tags/%E6%96%B9%E5%B7%AE/"/>
    
      <category term="python" scheme="https://mu4yu3.github.io/tags/python/"/>
    
      <category term="统计学" scheme="https://mu4yu3.github.io/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>忘了痛或许可以，忘了你却太不容易——那些丢失的文件啊……</title>
    <link href="https://mu4yu3.github.io/2018/04/04/open_source_series_1_nextcloud/"/>
    <id>https://mu4yu3.github.io/2018/04/04/open_source_series_1_nextcloud/</id>
    <published>2018-04-04T13:48:35.000Z</published>
    <updated>2018-04-10T05:57:35.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mu4yu3.github.io/tags/自由价更高/">#<strong>自由价更高</strong>#</a>是我在2018年新开的开源软件推荐系列，不定期更新。</p><p>这个系列主要深度介绍一些比较著名的开源软件，包括一些适合企业和个人，自用或商用的开源软件，所有软件均提供源码地址。</p><p>这是本系列的第 <strong>1</strong> 篇文章。</p><hr><p>我们都知道，初用电脑的人，往往会担心自己误操作“损坏设备”，或者无意间误删除“重要的文件”，而唯一可以改变这种心理负担的方法，就是抛开一切，多练多用。</p><p>当然，电脑的脾气，毕竟是很难揣测的（嘿），就算不是新手，或多或少还是有风险的……比如丢失珍贵回忆的照片，又比如，丢失公司重要的合同文件。</p><a id="more"></a><h2 id="问：怎么解决呢？"><a href="#问：怎么解决呢？" class="headerlink" title="问：怎么解决呢？"></a>问：怎么解决呢？</h2><p>应对丢失文件的风险，最佳方法就是备份。</p><p>行业内对于备份的最佳实践，就是所谓的<code>两地三备份</code>。简单来说，就是自己使用一份，<code>本地备份</code>一份，<code>异地备份</code>一份。</p><p>这里插播一段：很久以前，是没有所谓<code>异地备份</code>这个概念的。传说这是当年911的时候，同在双子楼的原始数据，和备份中心都被摧毁了。因为再没有更多的备份，有的企业丢失数据后倒闭了。从此业内发展出了<code>异地备份</code>的概念。</p><p>换言之，从理论上来说，<code>两地三备份</code>足够对抗飞机幢大楼、地震、甚至是核弹摧毁城市的风险。</p><p>使用备份的逻辑是：假设原始数据真的丢失了，通过备份的数据，还可以再还原回来。</p><h2 id="问：那是不是只要备份就ok了？"><a href="#问：那是不是只要备份就ok了？" class="headerlink" title="问：那是不是只要备份就ok了？"></a>问：那是不是只要备份就ok了？</h2><p>本来只有1份的数据，现在变成了N份，每一份都有各自独立的泄露风险，相当于<code>泄露风险</code> x <code>N</code>。</p><p>备份的过程需要传输，传输的过程中也有泄露的风险，总风险等于<code>本地泄露风险</code> x <code>N</code> + <code>传输泄露风险</code> x <code>N-1</code></p><p>所以，对于数据安全的关注，也应该对应 x <code>2N-1</code>。</p><p>数据安全中，加密是很重要的组成部分。</p><p>使用加密的逻辑是：假设数据真的泄露了，没有解密的钥匙，别人得到的也只是一堆加密后的乱码。</p><h2 id="问：搞这么多份备份，不麻烦么？"><a href="#问：搞这么多份备份，不麻烦么？" class="headerlink" title="问：搞这么多份备份，不麻烦么？"></a>问：搞这么多份备份，不麻烦么？</h2><p>搞备份，最麻烦的部分是同步。每一个备份点，都需要和其他数据点进行同步操作。</p><p>如果同步操作是手动的，那就真的很麻烦。如果是全自动的，那就一劳永逸。</p><p>同步里面要考虑2个问题：<code>时长</code>，还有<code>周期</code>。</p><p>先说<code>周期</code>，这个概念很简单，就是多长时间同步一次，比如1天、1小时、1分钟。周期决定了对丢失数据的容忍度。</p><p>例如：原始数据丢失了，备份数据可能是1天前的，那么今天的新数据就彻底丢失了。想想双11的taobao每秒钟产生的订单量，就该知道电商们对于一秒钟的数据丢失都无法容忍。</p><p>再说<code>时长</code>，指的是同步一次需要花费多长时间，比如5秒钟，或者5分钟。这里可以看出来。时长制约了周期，如果时长是5分钟，那么周期设为1分钟就毫无意义了。</p><p>那么时长是怎么决定的呢？时长取决于<code>数据同步量</code>和<code>传输带宽</code>。前者越小，后者越大，时长就越短。</p><p>有2个策略会影响<code>数据同步量</code>，全备份，和差异备份。全备份就是所有数据都要同步一遍，差异备份只同步上一次备份和本次备份中的差异部分。</p><p>关于<code>传输带宽</code>，这取决于投资在带宽上的钱。需要关注的是：源数据的上传带宽，和备份点的下载带宽，此外，还有一句老话：永远不要低估一辆装满硬盘，在高速公路上飞驰的卡车的带宽。</p><h2 id="问：这不是篇推荐么，怎么看到现在还不知道推荐的啥？"><a href="#问：这不是篇推荐么，怎么看到现在还不知道推荐的啥？" class="headerlink" title="问：这不是篇推荐么，怎么看到现在还不知道推荐的啥？"></a>问：这不是篇推荐么，怎么看到现在还不知道推荐的啥？</h2><p>嗯……这个问题问得好，但我还没打算马上告诉你。先来说一个人。</p><p><img src="https://upload.wikimedia.org/wikipedia/en/6/62/Gcds.jpeg" alt="光头大叔" title="Frank Karlitschek at Akademy 2009"></p><p>拂髯客·卡利切克（Frank Karlitschek），出生于1973年，德国人，现居住在斯图加特（Stuttgart），2001年成为<a href="https://en.wikipedia.org/wiki/KDE" target="_blank" rel="noopener">KDE</a>贡献者，2003年进入<a href="https://en.wikipedia.org/wiki/KDE_e.V." target="_blank" rel="noopener">KDE e.V.</a>，2009年被选为KDE e.V.董事会成员和VP，有自己的<a href="http://karlitschek.de" target="_blank" rel="noopener">个人网站</a>。</p><p>他有一句名言：</p><blockquote><p>Privacy is the foundation of democracy（隐私是民主的基础）</p></blockquote><p>他认为，人们应该拥有 “在互联网时代，控制自己的数据” 的基本权利。有兴趣的可以看一下<a href="http://karlitschek.de/2016/02/the-privacy-endgame/" target="_blank" rel="noopener">他的原文</a></p><p>插一句：对比百毒公司李老板的话：中国人……隐私……换取……，在这个思想上，部分德国人和部分中国人有差异。</p><p>回过头来，再说 拂髯客，他在2010年1月，宣布开发 OwnCloud。</p><p>2011年成立了公司，把代码从KDE中剥离出来，放在了GitHub上，吸引投资者，仅2014年就有630万美金的投资。</p><p>此后的故事就不那么美好了。</p><p>2016年4月 拂髯客 离开了 OwnCloud 公司，并在随后的6月，成立了一家名为 Nextcloud 的新公司和项目（仿佛是MySQL和MariaDB故事的翻版，历史常常重演）。</p><p>OwnCloud 继续着它的商业故事，我们把目光转移到 Nextcloud 上。</p><p>拂髯客 从OwnCloud离开时，有一批开发者追随着他一起离开，进入了Nextcloud项目。Nextcloud项目在GitHub上，是OwnCloud项目的一个分支，从它们分叉开始，就各自演进了。</p><p>对的，读到这里你应该已经意识到了，要推荐的，就是这个Nextcloud项目。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/6/60/Nextcloud_Logo.svg" alt="Nextcloud Logo"></p><p><img src="https://upload.wikimedia.org/wikipedia/commons/c/ce/Nextcloud_File_list.png" alt="File list in Nextcloud 12.0.4"></p><h2 id="问：好吧，它能干点啥？"><a href="#问：好吧，它能干点啥？" class="headerlink" title="问：好吧，它能干点啥？"></a>问：好吧，它能干点啥？</h2><p>Nextcloud是一整套软件，用于创建和使用文件托管服务，有客户端-服务器端，这是<a href="https://en.wikipedia.org/wiki/Nextcloud" target="_blank" rel="noopener">维基百科上的定义</a>。</p><p>如果你用过Dropbox，大概功能类似。最大的区别是Nextcloud是自由开源的，允许自己管理服务器端。</p><p>和Dropbox相比，Nextcloud是一个开放式的平台，允许以插件（Nextcloud称之为applications）的形式扩展附加功能。用户可以完全控制自己的数据。</p><p>Nextcloud拥有windows、linux、macOS、甚至是移动端Android, iOS的客户端，全平台支持。</p><p>想想iOS上的iCloud，月费50 GB：¥6；200 GB：¥21；2 TB：¥68。看上去似乎不多，按年费算，分别是：¥72、¥252、¥816。</p><p>Nextcloud在服务器端、在传输过程中，都可以加密。</p><p>客户端和服务器端会自动同步。同步的内容，可以是文件、文件夹、日历（CalDAV）、联系人（CardDAV）、计划任务、甚至是流媒体（Ampache）。</p><p>你可以发送一个网址，用来共享文件给其他人。可以加密、也可以限定共享的有效期。</p><h2 id="问：这不就是个网盘，干嘛不用百毒网盘？"><a href="#问：这不就是个网盘，干嘛不用百毒网盘？" class="headerlink" title="问：这不就是个网盘，干嘛不用百毒网盘？"></a>问：这不就是个网盘，干嘛不用百毒网盘？</h2><p>如果还有这个疑问，说明你属于上文所说的 “部分中国人” 。</p><h2 id="追根溯源"><a href="#追根溯源" class="headerlink" title="追根溯源"></a>追根溯源</h2><p>Nextcloud在GitHub上，有自己的<a href="https://github.com/nextcloud" target="_blank" rel="noopener">开源组织</a>，旗下围绕着Nextcloud有多个项目，其中server的<a href="https://github.com/nextcloud/server" target="_blank" rel="noopener">源代码</a>使用了<a href="https://github.com/nextcloud/server/blob/master/COPYING" target="_blank" rel="noopener">AGPL</a>的开源协议。</p><p>对开源协议不太清楚的读者，可以参考<a href="http://www.ruanyifeng.com" target="_blank" rel="noopener">阮一峰</a>所写的<a href="/blog/2017/10/open-source-license-tutorial.html">《开源许可证教程》</a>和<a href="http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html" target="_blank" rel="noopener">《如何选择开源许可证？》</a></p><h2 id="多说两句"><a href="#多说两句" class="headerlink" title="多说两句"></a>多说两句</h2><p>这是本系列的第1篇文章，所以多说两句，讲一下这个系列的入选条件，共有3条。</p><h3 id="开发活跃"><a href="#开发活跃" class="headerlink" title="开发活跃"></a>开发活跃</h3><p>关于开源和闭源软件谁更安全，有2种观点。认为开源不安全的观点，主要针对的是源代码开放，更容易寻找漏洞。</p><p>但其实这不是最大的问题，漏洞找的快，堵的也快。只要开发活跃，即时更新，通常最新版本的安全性还是相对较高的。</p><p>举例子：根据统计，Nextcloud在GitHub上，从2018年4月1日到8日这<code>7</code>天，共有<code>38</code>个Merged Pull Requests，<code>12</code>个Proposed Pull Requests，<code>49</code>个Closed Issues，<code>24</code>个New Issues。</p><p><code>15</code>个开发者，在master分支上，推送了<code>50</code>个提交；在其他分支上，推送了<code>186</code>个提交，在master分支上，有<code>265</code>个文件被修改，增加了<code>1963</code>处，删除了<code>642</code>处。</p><p>这些数字，从一个侧面，反映出项目的活跃程度。</p><h3 id="持续部署可行性"><a href="#持续部署可行性" class="headerlink" title="持续部署可行性"></a>持续部署可行性</h3><p>光是开发活跃，如果部署之后，长时间不更新，那也是没用的。</p><p>所以最大的问题是：如何能够持续不断的使用最新版本。在以往更新需要手动的年代，那需要投入大量的人力。</p><p>目前持续集成、持续部署的技术不断发展，让自动化这一过程变成了可行。</p><p>但并不是每个开源项目都对持续部署的方式友好的。</p><p>举个例子：Nextcloud提供官方的<a href="https://hub.docker.com/_/nextcloud/" target="_blank" rel="noopener">docker镜像</a>，在docker的仓库里可以找到，这就是友好的一种方式。同样，Nextcloud在<a href="https://admin.fedoraproject.org/pkgdb/package/rpms/nextcloud/" target="_blank" rel="noopener">Fedora的repository</a>里也是可用的，这是另一种友好的方式。</p><h3 id="实际部署"><a href="#实际部署" class="headerlink" title="实际部署"></a>实际部署</h3><p>最后一个入选条件是，实际上曾经被我用过，并觉得好，才会拿出来推荐呀（嘿）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://mu4yu3.github.io/tags/自由价更高/&quot;&gt;#&lt;strong&gt;自由价更高&lt;/strong&gt;#&lt;/a&gt;是我在2018年新开的开源软件推荐系列，不定期更新。&lt;/p&gt;
&lt;p&gt;这个系列主要深度介绍一些比较著名的开源软件，包括一些适合企业和个人，自用或商用的开源软件，所有软件均提供源码地址。&lt;/p&gt;
&lt;p&gt;这是本系列的第 &lt;strong&gt;1&lt;/strong&gt; 篇文章。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;我们都知道，初用电脑的人，往往会担心自己误操作“损坏设备”，或者无意间误删除“重要的文件”，而唯一可以改变这种心理负担的方法，就是抛开一切，多练多用。&lt;/p&gt;
&lt;p&gt;当然，电脑的脾气，毕竟是很难揣测的（嘿），就算不是新手，或多或少还是有风险的……比如丢失珍贵回忆的照片，又比如，丢失公司重要的合同文件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="自由价更高" scheme="https://mu4yu3.github.io/tags/%E8%87%AA%E7%94%B1%E4%BB%B7%E6%9B%B4%E9%AB%98/"/>
    
      <category term="开源软件" scheme="https://mu4yu3.github.io/tags/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="open_source" scheme="https://mu4yu3.github.io/tags/open-source/"/>
    
      <category term="文件托管" scheme="https://mu4yu3.github.io/tags/%E6%96%87%E4%BB%B6%E6%89%98%E7%AE%A1/"/>
    
      <category term="nextcloud" scheme="https://mu4yu3.github.io/tags/nextcloud/"/>
    
  </entry>
  
  <entry>
    <title>certbot的泛域名支持</title>
    <link href="https://mu4yu3.github.io/2018/03/21/certbot_wildcard_certificates/"/>
    <id>https://mu4yu3.github.io/2018/03/21/certbot_wildcard_certificates/</id>
    <published>2018-03-21T13:05:09.000Z</published>
    <updated>2018-03-21T13:05:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>距离Let’s Encrypt添加泛域名的支持已经有一段时间了。</p><p>今天尝试使用了certbot申请。</p><a id="more"></a><h2 id="首次尝试"><a href="#首次尝试" class="headerlink" title="首次尝试"></a>首次尝试</h2><p>一般来说，第一次不成功的概率很高。</p><p>这次也不例外。甩出了一句报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The currently selected ACME CA endpoint does not support issuing wildcard certificates.</span><br></pre></td></tr></table></figure><p>难道是certbot还没有支持泛域名么？</p><h2 id="查查看"><a href="#查查看" class="headerlink" title="查查看"></a>查查看</h2><p>大家都知道，不成功的时候，查官方文档就对了。</p><p>果然在<a href="https://certbot.eff.org/docs/install.html?highlight=wildcard" target="_blank" rel="noopener">官方文档</a>中，有这样一段话：</p><blockquote><p>If you would like to obtain a wildcard certificate from Let’s Encrypt’s ACMEv2 server,<br>you’ll need to include <code>--server https://acme-v02.api.letsencrypt.org/directory</code> on the command line as well.</p></blockquote><p>所以这时候，将使用的命令改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm --name certbot \</span><br><span class="line">-v &quot;/opt/docker/certbot/etc/letsencrypt:/etc/letsencrypt&quot; \</span><br><span class="line">-v &quot;/opt/docker/certbot/var/lib/letsencrypt:/var/lib/letsencrypt&quot; \</span><br><span class="line">certbot/certbot \</span><br><span class="line">certonly \</span><br><span class="line">--server https://acme-v02.api.letsencrypt.org/directory \</span><br><span class="line">--manual \</span><br><span class="line">--preferred-challenges dns</span><br></pre></td></tr></table></figure><p>果然，这样就可以成功申请类似 <code>*.test.com</code> 这样泛域名的证书了。</p><h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p>如果被运营商屏蔽了80、443端口，可以使用 <code>--preferred-challenges dns</code>。</p><p>这样只需要在DNS记录中，增加一条 <code>_acme-challenge.test.com</code> 的txt记录，可以避开端口认证，申请证书。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;距离Let’s Encrypt添加泛域名的支持已经有一段时间了。&lt;/p&gt;
&lt;p&gt;今天尝试使用了certbot申请。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Let’s Encrypt" scheme="https://mu4yu3.github.io/tags/Let%E2%80%99s-Encrypt/"/>
    
      <category term="certbot" scheme="https://mu4yu3.github.io/tags/certbot/"/>
    
      <category term="Wildcard Certificates" scheme="https://mu4yu3.github.io/tags/Wildcard-Certificates/"/>
    
      <category term="泛域名" scheme="https://mu4yu3.github.io/tags/%E6%B3%9B%E5%9F%9F%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>如何挑选手机</title>
    <link href="https://mu4yu3.github.io/2018/03/15/how_to_choose_a_smartphone/"/>
    <id>https://mu4yu3.github.io/2018/03/15/how_to_choose_a_smartphone/</id>
    <published>2018-03-15T09:42:37.000Z</published>
    <updated>2018-03-15T14:07:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近，给自己选了手机，给家人选了手机。</p><p>总结了一下（仅为自身考虑的）心得，供大家参考。</p><p>一共有13个问题，不区分顺序。</p><a id="more"></a><h2 id="选择一个操作系统"><a href="#选择一个操作系统" class="headerlink" title="选择一个操作系统"></a>选择一个操作系统</h2><ol><li>iPhone使用的iOS系统，好用，（相对）安全，权限干净，与其他apple设备兼容。</li><li>Android，Google出品，灵活性好，可定制化程度高，价格便宜。</li><li>其他系统，比如windows phone、Ubuntu。</li></ol><p>如果没有特殊原因，不用考虑其他系统。<br>（基本上，连他们的开发厂商都已经放弃了这些系统，比如M$）</p><p>在Android和iPhone中选一个就好了。</p><h2 id="选一个可以接受的价格区间"><a href="#选一个可以接受的价格区间" class="headerlink" title="选一个可以接受的价格区间"></a>选一个可以接受的价格区间</h2><p>这和自己的收入相关，也和其他问题有一定的相关性。</p><p>例如同时代，同样配置的设备，iPhone总是比Android设备要贵一些。</p><p>如果iPhone和Android设备价格相同，那么iPhone在配置上总是要低一些的。</p><p><del>但iPhone配置低不一定体验不好，相反，通常iOS的优化会更好一点，流畅度更高些。</del></p><p>以前是这样，现在不好说，尤其是对比Google亲儿子，呵呵。</p><h2 id="考虑手机淘汰的时间"><a href="#考虑手机淘汰的时间" class="headerlink" title="考虑手机淘汰的时间"></a>考虑手机淘汰的时间</h2><p>现在的手机设备，淘汰很快，一般2~3年已经算是超龄服役了。</p><p>这里可以参考厂商对设备的承诺。</p><p>Apple一般在iPhone发售3年左右，iOS更新就不再支持旧设备了。</p><p>Google承诺了Pixel设备3年的系统更新。</p><p>通常如果系统不能再继续更新，尤其是安全补丁不能再更新，意味着这个设备已经被强制退役了。</p><p>不考虑摔坏，进水等意外情况。结合预计使用的时间，再加上价格区间，可以计算平均到每一天的使用成本。</p><h2 id="考虑现有的设备、系统、软件兼容性"><a href="#考虑现有的设备、系统、软件兼容性" class="headerlink" title="考虑现有的设备、系统、软件兼容性"></a>考虑现有的设备、系统、软件兼容性</h2><p>如果平时使用mac、ipad，在AppStore买了一堆软件，那么显然使用iPhone是最佳选择。</p><p>如果是Gmail、或者其他Google产品的重度用户，平时用M$的office比较多，那么可以考虑选Android。</p><h2 id="考虑依赖的套件"><a href="#考虑依赖的套件" class="headerlink" title="考虑依赖的套件"></a>考虑依赖的套件</h2><p>iOS提供Siri、facetime、iCloud、imessage。</p><p>Android提供Gmail、Google Drive。</p><p>如果你非要使用Cortana，那么可以考虑Windows Phone。（啊哈）</p><p>其实为了减少对某个平台的依赖性，用户往往会对强制单一平台的产品，有天然的抵制心理。</p><p>从用户层面上来说，支持多平台的app产品比较友好，但对厂商来说，这样不容易形成技术壁垒。</p><h2 id="考虑常用的软件"><a href="#考虑常用的软件" class="headerlink" title="考虑常用的软件"></a>考虑常用的软件</h2><p>比如银行的app。</p><p>因为众所周知的原因，很多国产app是不在 Google play 市场上架的。</p><h2 id="考虑硬件问题"><a href="#考虑硬件问题" class="headerlink" title="考虑硬件问题"></a>考虑硬件问题</h2><ol><li>根据sim卡的运营商，考虑网络问题（其实也是芯片问题）</li><li>考虑<code>运行内存</code>和<code>存储内存</code>空间大小的问题，包括是否可以<code>扩展存储</code>。</li><li>考虑屏幕尺寸、配置</li><li>考虑芯片配置（包括cpu速度等）</li><li>考虑摄像头的配置</li></ol><p>其实每一项都可以单列，这里把它们汇总了。</p><p>需要注意的是，有些硬件不适合单纯的比较参数。数字上的差别不一定能反映真实的效果。</p><p>有些硬件，不会被使用（比如指纹），又或者通常都具备（比如GPS），所以不列入特别考虑。</p><h2 id="考虑有中国特色的问题"><a href="#考虑有中国特色的问题" class="headerlink" title="考虑有中国特色的问题"></a>考虑有中国特色的问题</h2><p>如果选择iPhone，需要考虑iCloud国籍问题。</p><p>如果选择Android，需要考虑访问Google的问题。</p><h2 id="如果选择Android的问题"><a href="#如果选择Android的问题" class="headerlink" title="如果选择Android的问题"></a>如果选择Android的问题</h2><p>如果买的是Google的亲儿子，那么这一项就不用额外考虑了。</p><p>如果是其他品牌。那么需要考虑刷第三方rom的问题。</p><p>第三方rom首选<a href="http://lineageos.org/" target="_blank" rel="noopener">lineageOS</a>，它是CyanogenMod的继任者。</p><p>访问lineageOS的<a href="https://wiki.lineageos.org/devices/" target="_blank" rel="noopener">wiki</a>，可以查看哪些手机纳入了官方支持范围。</p><p>因为lineageOS是开源的项目，如果自己的手机型号，官方不支持，还可以去<a href="https://forum.xda-developers.com" target="_blank" rel="noopener">XDA-Developers</a>查下非官方的开发者。</p><p>根据经验，品牌大，使用人数多，销售范围广，使用高通的芯片，比较容易被支持。</p><p>比如Samsung、Sony、LG，都有很多型号被官方或民间支持。</p><p>国产品牌中，Xiaomi和OnePlus，支持的也比较多。</p><p>比较坑的是：Huawei、ZTE、Nubia这些，品牌不算小，支持的型号很少。</p><p>手边上有4个旧设备，分别是：</p><ol><li>Samsung Galaxy S II i9100g，使用了Texas Instruments OMAP 4430的芯片，非官方lineageOS支持。</li><li>红米1，联发科 MT6589T的芯片，没有lineageOS的rom。</li><li>华为 Mate 7，麒麟925，海思的芯片，没有lineageOS的rom。</li><li>Google Nexus 4，官方lineageOS支持，目前支持到Android 7.1.2版本，也就是lineageOS 14.1版本。</li></ol><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>结果选择了Android。</p><p>感觉没有13个问题的读者，可以再数数。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近，给自己选了手机，给家人选了手机。&lt;/p&gt;
&lt;p&gt;总结了一下（仅为自身考虑的）心得，供大家参考。&lt;/p&gt;
&lt;p&gt;一共有13个问题，不区分顺序。&lt;/p&gt;
    
    </summary>
    
    
      <category term="smartphone" scheme="https://mu4yu3.github.io/tags/smartphone/"/>
    
      <category term="android" scheme="https://mu4yu3.github.io/tags/android/"/>
    
      <category term="iPhone" scheme="https://mu4yu3.github.io/tags/iPhone/"/>
    
      <category term="lineageOS" scheme="https://mu4yu3.github.io/tags/lineageOS/"/>
    
  </entry>
  
  <entry>
    <title>Pixel2 游记</title>
    <link href="https://mu4yu3.github.io/2018/02/25/my_pixel2/"/>
    <id>https://mu4yu3.github.io/2018/02/25/my_pixel2/</id>
    <published>2018-02-25T05:46:04.000Z</published>
    <updated>2018-03-06T04:39:35.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Now this is not the end, it is not even the beginning of the end.<br>But it is, perhaps, the end of the beginning.</p><p>  –Winston Churchill</p></blockquote><p>自从上一个iPhone5S掉海水，一直在iPhone和Android之间摇摆。</p><p>一条新闻促使我下定了决心：<a href="http://www.williamlong.info/archives/5214.html" target="_blank" rel="noopener">苹果中国iCloud服务转由国企运营管理</a></p><p>新年前，拜托了友人小鱼，在Google store下单购买了一部无锁版的pixel2。</p><p>不远两万里从美国带回到国内。</p><p>今天，友人携带着这部pixel2，踏上返美的归途。</p><p>感谢我的友人。</p><p>千里鹅毛，尚且礼轻情重，更何况是带着一部pixel2，绕了地球一圈。</p><a id="more"></a><h2 id="人生若只如初见"><a href="#人生若只如初见" class="headerlink" title="人生若只如初见"></a>人生若只如初见</h2><p>时间拨回到新年初三，与友人相聚，对饮四人。</p><p>那是第一次看到我的pixel2。</p><p>拆箱犹豫了一下，想着实用为主，没有拍照。</p><p>先看说明书和附件：</p><ul><li>充电插头 x 1</li><li>USB C to USB C 数据线 x 1</li><li>USB C to USB 转接头 x 1 （用来导入旧手机数据）</li><li>USB C to 耳机接口 x 1</li></ul><p>心里咯噔了一下，家里的笔记本很久没有更新了。现用的笔记本没有USB C 的接口。</p><p>之前没做功课，也没准备USB C 的转接口，看来 <code>adb</code> 是暂时用不起来了。</p><p>不过这也不是什么大问题。</p><p>开机，初始化，上梯子，登陆Google账号，看到首屏。</p><p>那是一个海滩，还有海浪拍岸的动态效果。</p><p>简单试了一下拍照。</p><p>一向不在意外貌，屏幕，拍照，但也觉得好看，好看，好看。</p><p>第一次登陆进去，会自动更新google play，下载Google全家桶软件。</p><p>直接睡觉去，睡醒了，自然更新完成。</p><p>这时候发现了第一个问题：OTA的update始终报错，无法完成。</p><h2 id="衣带渐宽终不悔，为伊消得人憔悴"><a href="#衣带渐宽终不悔，为伊消得人憔悴" class="headerlink" title="衣带渐宽终不悔，为伊消得人憔悴"></a>衣带渐宽终不悔，为伊消得人憔悴</h2><p>以前有一个nexus7的平板，OTA的update都是挂上梯子就可以下载。</p><p>这次pixel2的OTA更新不了，倒也不太着急，毕竟还可以直接刷Factory Images。</p><p>上google，找镜像，到<a href="https://developers.google.com/android/images" target="_blank" rel="noopener">官网</a>。</p><p>看到这样一句话：</p><blockquote><p>For Pixel 2: To flash the bootloader, Pixel 2’s boot loader must be updated to at least Oreo MR1’s version first. This may be done by applying an over-the-air (OTA) update, or sideloading a full OTA with the instructions on that page.</p></blockquote><p>打开设置，查看版本，还是OPD1.170816.010，这是8.0.0的版本。</p><p>看来得先升级版本，可OTA升不了，只能刷 FULL OTA Images。</p><p>新年初四去拜年，在另一位友人家中看到一根<a href="https://item.mi.com/1164700050.html" target="_blank" rel="noopener">小米二合一数据线</a>。</p><p>同时支持Type-C和Micro USB，不错。</p><p>想着新年快递不行，等到新年初六，跑了一趟小米之家，现场买了一根回来。</p><p>按照<a href="https://developers.google.com/android/ota" target="_blank" rel="noopener">官方文档</a>操作，先下载了2个镜像：</p><ul><li><p><a href="https://dl.google.com/dl/android/aosp/walleye-ota-opm1.171019.011-4f58f0f0.zip" target="_blank" rel="noopener">8.1.0 (OPM1.171019.011, Dec 2017)</a><br>初版8.1.0的镜像，<br>SHA-256 Checksum：<br>4f58f0f0cd1e90db605bdd918decac55ce166ea999f437a50aaf388dc6c7fb11</p></li><li><p><a href="https://dl.google.com/dl/android/aosp/walleye-ota-opm1.171019.019-5b2af7a9.zip" target="_blank" rel="noopener">8.1.0 (OPM1.171019.019, Feb 2018)</a><br>最新的镜像，<br>SHA-256 Checksum：<br>5b2af7a9f00da30a2299868e72df2aeffe400d74a470b39586ce77f6962caaec</p></li></ul><p>连接手机电脑，下载最新版的<a href="https://developer.android.com/studio/releases/platform-tools.html" target="_blank" rel="noopener">Android SDK Platform-Tools</a></p><p>设置 -&gt; 关于手机 -&gt; 打开<code>开发者选项</code></p><p>切换到<code>开发者选项</code> -&gt; 打开<code>USB debugging</code></p><p>进入recovery模式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb reboot recovery</span><br></pre></td></tr></table></figure></p><p>按住电源键，按音量上键，选择<code>Apply update from ADB</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb devices</span><br><span class="line">adb sideload walleye-ota-opm1.171019.019-5b2af7a9.zip</span><br></pre></td></tr></table></figure></p><p>先后试了2个OTA的包，都升级成功。</p><h2 id="蓦然回首，bug却在，灯火阑珊处。"><a href="#蓦然回首，bug却在，灯火阑珊处。" class="headerlink" title="蓦然回首，bug却在，灯火阑珊处。"></a>蓦然回首，bug却在，灯火阑珊处。</h2><p>作为一个普通用户来说，这时候手机已经更新到最新状态。</p><p>可以下载app，将旧手机的资料转移，可以正常使用了。</p><p>只因为我在<code>开发者选项</code>多看了一看，发现<code>OEM unlocking</code>开关是灰色的。</p><p>纳尼！？说好的无锁版呢？</p><p>开始了漫漫debug之路。</p><ol><li>恢复出厂设置（有2种，在UI界面中，在recovery中）</li><li>初始化，开wifi，上梯子，进系统，在设置 -&gt; 关于手机 -&gt; 打开<code>开发者选项</code></li><li>切换到<code>开发者选项</code>，打开<code>USB debugging</code>和<code>OEM unlocking</code>（第一次的时候，<code>OEM unlocking</code>是可以打开的）</li><li>这个时候，无论是关机，重启，或者放置一段时间，<code>OEM unlocking</code>始终是激活状态。</li><li>关机重启，进入fastboot模式</li><li>通过数据线连接手机和PC (试了win10和linux)</li><li>检查设备连接良好，设备已经识别</li><li><p>命令检查设备已识别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./fastboot devices</span><br><span class="line">FAXXXXXXXXXX    fastboot</span><br></pre></td></tr></table></figure></li><li><p>查询设备信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">./fastboot oem device-info</span><br><span class="line">(bootloader) Verity mode: true</span><br><span class="line">(bootloader) Device unlocked: false</span><br><span class="line">(bootloader) Device critical unlocked: true</span><br><span class="line">(bootloader) Charger screen enabled: true OKAY</span><br><span class="line">[  0.025s] finished. total time: 0.025s</span><br></pre></td></tr></table></figure></li><li><p>尝试解锁（测试了 <code>oem unlock</code> 或者 <code>flashing unlock</code>)，均失败。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">./fastboot oem unlock</span><br><span class="line">FAILED (remote: Flashing Unlock is not allowed</span><br><span class="line">)</span><br><span class="line">finished. total time: 0.010s</span><br><span class="line">./fastboot flashing unlock</span><br><span class="line">FAILED (remote: Flashing Unlock is not allowed</span><br><span class="line">)</span><br><span class="line">finished. total time: 0.009s</span><br></pre></td></tr></table></figure></li><li><p>重启手机</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./fastboot reboot</span><br><span class="line">finished. total time: 5.035s</span><br></pre></td></tr></table></figure></li><li><p>回到<code>开发者选项</code>，这时候<code>OEM Unlocking</code>已经变成灰色，不可切换状态。</p></li></ol><p>然后就是不断的重复这12个步骤。</p><p>期间不断调整各个步骤的实现方式，比如：</p><ol><li>使用UI回复出厂，使用recovery回复出厂。</li><li>初始化使用中文、英文；登陆Google账号，跳过登陆账号。</li><li>使用sim卡，不使用sim卡。</li><li>使用<code>adb</code>命令重启，使用按键重启。</li><li>使用不同的PC、接口、操作系统、adb版本……</li></ol><p>再把这些选项组合，穷举各种可能性……漫长的工作量……</p><p>最后，全部失败。</p><h2 id="独上高楼-望尽天涯"><a href="#独上高楼-望尽天涯" class="headerlink" title="独上高楼 望尽天涯"></a>独上高楼 望尽天涯</h2><p>开始在网上找了一下相关资料，xda上有人遇到相同的问题。</p><ul><li><a href="https://forum.xda-developers.com/pixel-2/help/oem-unlocking-issue-t3716668" target="_blank" rel="noopener">OEM Unlocking issue</a></li></ul><p>这人联系了Google，通过RMA换了一部新手机，问题解决了。</p><p>开始联系Google，登陆<a href="https://support.google.com/store" target="_blank" rel="noopener">Google Store Help</a>，点击<a href="https://support.google.com/store/contactflow?hl=en" target="_blank" rel="noopener">CONTACT US</a></p><p>不方便电话回访（没有美国手机号，留了中国手机号，无反馈 o_o! ），所以只好留了邮件地址，写明问题，等待回信。</p><p>同时到<a href="https://productforums.google.com/forum/?utm_medium=email&amp;utm_source=footer#!forum/phone-by-google" target="_blank" rel="noopener">Google产品论坛</a>，</p><p>新建了一个主题：<a href="https://productforums.google.com/forum/?utm_medium=email&amp;utm_source=footer#!topic/phone-by-google/lATXL2Zv53U" target="_blank" rel="noopener">Google Pixel 2 OEM Unlocking issue</a></p><p>有专家认为：</p><blockquote><p>If your device was purchased from the Google Store I don’t believe the bootloader should be locked. I think only the ones from Verizon are OEM locked.  I would suggest contacting support.</p></blockquote><p>查看了Google的问题跟踪系统，看到了 issue：</p><p><a href="https://issuetracker.google.com/issues/68897739" target="_blank" rel="noopener">Can NOT OEM unlock slider in Dev Options Pixel 2 HTC OPD1.170816.010</a></p><p>下面一百多个跟帖，显示这个问题绝对不是偶发。</p><p>目前可能的原因有2个：</p><ol><li>大概率，有一批Pixel2出厂即带bug（不是所有的，有人买了2台，1台有bug，1台可解锁），未来可能会因为update修复这个bug。</li><li>小概率，google发货的时候，把部分Verizon有锁版，当成无锁版，发货出来了（无法证实这个可能）。</li></ol><p>犹豫再三，决定拜托友人带回美国，尝试通过RMA换一部新手机。</p><p>对我来说，无法unlock bootloader的Android，还不如一部iPhone。</p><p>新年初九，夜，将Pixel2交还给友人。</p><p>感谢我的友人。</p><h2 id="夜来幽梦忽还乡"><a href="#夜来幽梦忽还乡" class="headerlink" title="夜来幽梦忽还乡"></a>夜来幽梦忽还乡</h2><p>6天，144个小时。</p><h2 id="2018-3-6-12-39-35-更新"><a href="#2018-3-6-12-39-35-更新" class="headerlink" title="2018/3/6 12:39:35 更新"></a>2018/3/6 12:39:35 更新</h2><p>友人已经帮我联系了Google，更换的新机已经入手。</p><p>接下来，就看这部新机，什么时候再跨过半个地球，来到中国。</p><p>也看Google的品控，会不会两次让人失望。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Now this is not the end, it is not even the beginning of the end.&lt;br&gt;But it is, perhaps, the end of the beginning.&lt;/p&gt;
&lt;p&gt;  –Winston Churchill&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;自从上一个iPhone5S掉海水，一直在iPhone和Android之间摇摆。&lt;/p&gt;
&lt;p&gt;一条新闻促使我下定了决心：&lt;a href=&quot;http://www.williamlong.info/archives/5214.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;苹果中国iCloud服务转由国企运营管理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;新年前，拜托了友人小鱼，在Google store下单购买了一部无锁版的pixel2。&lt;/p&gt;
&lt;p&gt;不远两万里从美国带回到国内。&lt;/p&gt;
&lt;p&gt;今天，友人携带着这部pixel2，踏上返美的归途。&lt;/p&gt;
&lt;p&gt;感谢我的友人。&lt;/p&gt;
&lt;p&gt;千里鹅毛，尚且礼轻情重，更何况是带着一部pixel2，绕了地球一圈。&lt;/p&gt;
    
    </summary>
    
    
      <category term="pixel2" scheme="https://mu4yu3.github.io/tags/pixel2/"/>
    
      <category term="OEM unlock" scheme="https://mu4yu3.github.io/tags/OEM-unlock/"/>
    
      <category term="bootloader" scheme="https://mu4yu3.github.io/tags/bootloader/"/>
    
  </entry>
  
  <entry>
    <title>Let’s Encrypt的泛域名支持</title>
    <link href="https://mu4yu3.github.io/2018/01/29/letsencrypt_wildcard_certificates/"/>
    <id>https://mu4yu3.github.io/2018/01/29/letsencrypt_wildcard_certificates/</id>
    <published>2018-01-29T03:33:46.000Z</published>
    <updated>2018-01-29T03:33:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>一直记着2018年1月，Let’s Encrypt将添加泛域名的支持。</p><p>因为之前的证书到2月1日到期，所以也没有及时更新。</p><p>刚刚准备更新证书的时候发现，<a href="https://certbot.eff.org/faq/#will-let-s-encrypt-issue-wildcard-certificates" target="_blank" rel="noopener">certbot</a>还没有支持泛域名。</p><a id="more"></a><p>查了一下，原来Let’s Encrypt在<a href="https://letsencrypt.org/2017/07/06/wildcard-certificates-coming-jan-2018.html" target="_blank" rel="noopener">1月4日放出了一个公共测试api，到2月27日才完全可用</a>。</p><p>总觉得存在疑似“跳票”行为，不过也有可能是自己误解了。</p><p>好吧，继续耐心等待就好。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直记着2018年1月，Let’s Encrypt将添加泛域名的支持。&lt;/p&gt;
&lt;p&gt;因为之前的证书到2月1日到期，所以也没有及时更新。&lt;/p&gt;
&lt;p&gt;刚刚准备更新证书的时候发现，&lt;a href=&quot;https://certbot.eff.org/faq/#will-let-s-encrypt-issue-wildcard-certificates&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;certbot&lt;/a&gt;还没有支持泛域名。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Let’s Encrypt" scheme="https://mu4yu3.github.io/tags/Let%E2%80%99s-Encrypt/"/>
    
      <category term="Wildcard Certificates" scheme="https://mu4yu3.github.io/tags/Wildcard-Certificates/"/>
    
      <category term="泛域名" scheme="https://mu4yu3.github.io/tags/%E6%B3%9B%E5%9F%9F%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>智能家庭</title>
    <link href="https://mu4yu3.github.io/2018/01/22/smart_home/"/>
    <id>https://mu4yu3.github.io/2018/01/22/smart_home/</id>
    <published>2018-01-22T12:02:53.000Z</published>
    <updated>2018-01-24T15:20:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>家里有闲置的Android设备，有不限时、不限流量、拥有公网IP的宽带，总想着把它们利用起来。</p><p>Android基于一个修改版的linux内核，有大把的开源软件可以运行在这个操作系统上。</p><p>然而有一个问题，就是锂电池的使用与寿命，虽说是闲置、淘汰了的Android设备，但始终插着电源线充电显然不妥。</p><p>比较理想的方式是，建立一个自动化的充电机制：</p><p><strong>Android设备始终插着电源线，但并不是始终充电。当电池电量低（低于20%）时，能够自动启动充电，而电量高（超过90%）时，自动关闭充电。</strong></p><p>最初使用了一个<a href="https://www.mi.com/mj-socket/" target="_blank" rel="noopener">米家智能插座 基础版</a>来实现。</p><p>这里吐槽一下<a href="https://home.mi.com/" target="_blank" rel="noopener">米家</a>app，触发插座开关的可选项实在是太少，也没有提供公开的API。</p><p>无奈已经买了硬件，自己挖的坑，自己填。</p><p>过程不细说了（如果有感兴趣的读者留言，可以考虑另外写一篇），结果是：</p><p>使用Android下的busybox中的crontab，周期性的检查 <code>/sys/class/power_supply/battery</code> 下的电量信息。</p><p>通过shell脚本，判断电量后，使用 <code>adb input keyevent</code> 和 <code>adb input swipe</code> 模拟屏幕操作。</p><p>使用米家app，把智能插座usb口的开关，放两个快捷方式在Android的桌面上，通过模拟屏幕操作点击。</p><p>如此实现了自动化充电的机制，这时可以把Android设备视作一个linux server，或者说，更像是一个Raspberry Pi，可以放飞自我了。</p><a id="more"></a><h2 id="新的格局"><a href="#新的格局" class="headerlink" title="新的格局"></a>新的格局</h2><p>最近对HomeKit比较感兴趣。</p><p>原本有一个iPhone 5s，升级了iOS11，正准备折腾一下HomeKit，结果这个手机在苏梅岛附近的Ko Ra Thian进了海水，上岸后没用了。</p><p>计划搁浅。</p><p>回来以后研究了一下，意外发现了2个开源项目：</p><p><a href="https://github.com/nfarina/homebridge" target="_blank" rel="noopener">Homebridge</a>，<br>一个轻量级Node.js server，可以模拟iOS HomeKit API。</p><p><a href="https://github.com/home-assistant/home-assistant" target="_blank" rel="noopener">Home Assistant</a>，<br>一个可以检测和控制智能家居设备的自动化平台，基于python3。</p><p>因为已经没有了iPhone，所以Homebridge就暂时不管它了。仔细看了一下Home Assistant，新的格局出现了，充电自动化的机制可以转化为：</p><ol><li>在Android中安装<a href="https://play.google.com/store/apps/details?id=ru.meefik.linuxdeploy" target="_blank" rel="noopener">Linux Deploy</a>或者<a href="https://play.google.com/store/apps/details?id=com.termux" target="_blank" rel="noopener">Termux</a>，提供python3的运行环境。</li><li>安装python3环境，提供Home Assistant的运行环境。</li><li>使用Home Assistant连接米家的智能插座、获取Android的电量信息，制定自动化的规则。</li></ol><p>这样做至少有3个好处：</p><ol><li>避免了因使用adb模拟点击，偶尔出现的失效现象，以及点亮屏幕浪费的电力。</li><li>在Home Assistant中可以比较方便的添加、修改、删除自定义规则，比shell script方便，并且有相对更完善的log记录。</li><li>可以打破米家app的局限；可以和其他品牌的设备联动；可以有更多的自定义触发、自定义条件。</li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>在实现的过程中，还是有一些意外情况发生的，好在最后都解决了。记录如下：</p><h3 id="安装Linux-Deploy"><a href="#安装Linux-Deploy" class="headerlink" title="安装Linux Deploy"></a>安装Linux Deploy</h3><p>Linux Deploy与Termux这2个都是Android中的神器，都是开源软件，但又各有区别。</p><p><a href="https://github.com/meefik/linuxdeploy" target="_blank" rel="noopener">Linux Deploy</a>，<br>在Android系统中安装一个完整的linux系统，可以选择多个发行版本，如fedora、debian、arch等。</p><p><a href="https://github.com/termux/termux-app" target="_blank" rel="noopener">Termux</a>，<br>在Android系统提供了一个terminal，并提供了一个类debian的linux环境。</p><p>Termux有一个限制，要求Android系统至少在5.0版本以上，有网友提出了低于5版本的支持请求，但<a href="https://github.com/termux/termux-app/issues/6" target="_blank" rel="noopener">被作者拒绝</a>了。Termux的好处是不强制要求root权限。</p><p>Linux Deploy对Android版本没有5.0的限制要求，但要求root权限。</p><p>这里再吐槽一下，家里闲置的是一位长辈淘汰下来的红米手机，有比较<a href="http://www.miui.com/search.php?mod=forum&amp;searchid=3764464&amp;orderby=dateline&amp;ascdesc=desc&amp;searchsubmit=yes&amp;kw=闪屏&amp;month=&amp;refineSearch=0" target="_blank" rel="noopener">严重的闪屏问题</a>。</p><p>而且<a href="http://www.miui.com/download-82.html#131" target="_blank" rel="noopener">对应的miui</a>已经升级到8版本，可使用的还是Android4.4版本。</p><p>所以这里使用了Linux Deploy。</p><p>国内的手机没有google play，红米也没有CyanogenMod或者LineageOS的rom。</p><p>所以先安装<a href="https://f-droid.org/zh_Hans/" target="_blank" rel="noopener">F-Droid</a>，然后安装<a href="https://f-droid.org/zh_Hans/packages/com.github.yeriomin.yalpstore/" target="_blank" rel="noopener">Yalp Store</a>。</p><p>Yalp Store可以从Google Play Store下载apk安装包。</p><p>安装Linux Deploy的过程，可以参考这3篇文章：<br><a href="https://github.com/meefik/linuxdeploy/wiki/How-to-use-application" target="_blank" rel="noopener">How to use application</a>、<br><a href="https://mlapp.cn/134.html" target="_blank" rel="noopener">Linux Deploy:在Android上部署Linux</a>、<br><a href="https://mlapp.cn/189.html" target="_blank" rel="noopener">备选方案:在Linux Deploy上使用镜像部署Linux系统</a></p><p>在这里，把一张8G的TF卡格式化为ext4格式，在Linux Deploy设置安装类型为磁盘，安装路径定位到TF卡。</p><p>安装了Fedora 27版本的系统，安装常用的软件（ssh、tmux、vim、git等），安装python3的环境：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dnf install python3 python3-pip python3-virtualenv</span><br></pre></td></tr></table></figure><h3 id="安装Home-Assistant"><a href="#安装Home-Assistant" class="headerlink" title="安装Home Assistant"></a>安装Home Assistant</h3><p>python3环境准备好以后，使用<code>virtualenv</code>建立一套“隔离”的python运行环境。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mkdir homeassistant</span><br><span class="line">cd homeassistant/</span><br><span class="line">python3 -m virtualenv venv</span><br><span class="line">source venv/bin/activate</span><br><span class="line">python3 -m pip install homeassistant</span><br><span class="line">hass --open-ui</span><br></pre></td></tr></table></figure><p>如果想要把hass运行在后台可以执行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hass --open-ui --daemon</span><br></pre></td></tr></table></figure><p>安装和启动hass的过程中，一般会自动安装有依赖关系的软件。</p><p>如果有无法自动安装的，可以根据给出的错误提示，逐个寻找对应的软件安装。</p><p>如果想偷懒，可以一股脑把常用的编译工具都装上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dnf groupinstall &quot;C Development Tools and Libraries&quot;</span><br></pre></td></tr></table></figure><p>有时候会提示某个库文件没找到，可以通过 <code>dnf provides</code> 命令来寻找对应的安装包，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf provides */opensslv.h</span><br></pre></td></tr></table></figure><p>根据给出的提示，安装对应的软件包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dnf install openssl-devel</span><br></pre></td></tr></table></figure><p>安装Home Assistant过程可以参考：<br><a href="https://home-assistant.io/getting-started/" target="_blank" rel="noopener">installation instructions</a>、<br><a href="https://sspai.com/post/39881" target="_blank" rel="noopener">入门智能家居，从 IFTTT 到 HomeKit 自动化（二）</a>、<br><a href="https://www.hachina.io/docs/355.html" target="_blank" rel="noopener">在Linux（树莓派）中安装Python3和HomeAssistant</a></p><h3 id="配置Home-Assistant"><a href="#配置Home-Assistant" class="headerlink" title="配置Home Assistant"></a>配置Home Assistant</h3><p>Home Assistant目前支持959种<a href="https://home-assistant.io/components/" target="_blank" rel="noopener">components</a>，分别可以实现不同的扩展功能。</p><p>这里用到了2个：</p><p><a href="https://home-assistant.io/components/sensor.linux_battery/" target="_blank" rel="noopener">Linux Battery</a>，<br>用来监控Android的电量信息。</p><p><a href="https://home-assistant.io/components/switch.xiaomi_miio/" target="_blank" rel="noopener">Xiaomi Smart WiFi Socket and Smart Power Strip</a>，<br>用来连接和控制小米智能插座。</p><p>这里遇到了一个问题，Linux Battery默认监控的目录类似 <code>/sys/class/power_supply/BAT1</code>，而Android默认的目录是 <code>/sys/class/power_supply/battery</code>。<br>所以按照默认的配置，启动hass时候，日志会报出”No battery found”的错误。</p><p>为了添加Android的支持，贡献了在github的<a href="https://github.com/home-assistant/home-assistant/pull/11852" target="_blank" rel="noopener">First pull request</a>。</p><p>成功解决电量监控，下一步是连接小米智能插座。</p><p>使用这篇文章<a href="https://home-assistant.io/components/vacuum.xiaomi_miio/#retrieving-the-access-token" target="_blank" rel="noopener">Retrieving the Access Token</a>中描述的方法，先使用米家app连接设备，然后将 <code>/data/data/com.xiaomi.smarthome/databases/miio2.db</code> 用 <code>sqlite3</code> 打开。</p><p>使用sql命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name,localIP,token from devicerecord;</span><br></pre></td></tr></table></figure><p>获取Token，按照文档格式要求写入配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">switch:</span><br><span class="line">  - platform: xiaomi_miio</span><br><span class="line">    name: Original Xiaomi Mi Smart WiFi Socket</span><br><span class="line">    host: 192.168.130.59</span><br><span class="line">    token: YOUR_TOKEN</span><br></pre></td></tr></table></figure><p>最后一步是编写自动化规则，可以参考<a href="https://home-assistant.io/docs/automation/editor/" target="_blank" rel="noopener">官方文档</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># Example automations.yaml entry</span><br><span class="line">- id: my_unique_id  # &lt;-- Required for editor to work.</span><br><span class="line">  alias: 90% USB Auto Shutdown</span><br><span class="line">  trigger:</span><br><span class="line">  - above: &apos;90&apos;</span><br><span class="line">    entity_id: sensor.battery</span><br><span class="line">    platform: numeric_state</span><br><span class="line">  condition:</span><br><span class="line">  - condition: state</span><br><span class="line">    entity_id: switch.original_xiaomi_mi_smart_wifi_socket_usb</span><br><span class="line">    state: &apos;on&apos;</span><br><span class="line">  action:</span><br><span class="line">  - data:</span><br><span class="line">      entity_id: switch.original_xiaomi_mi_smart_wifi_socket_usb</span><br><span class="line">    service: switch.turn_off</span><br></pre></td></tr></table></figure><p>以上规则实现了：当电池电量在90%以上时，如果小米插座的usb口是通电的，自动将其关闭。</p><p>同理设置当电量低于40%时，如果usb是不通电的，自动将其打开。</p><p>为什么是40%，而不是最初设想的20%。</p><p>接着吐槽小米，这个红米手机电量一旦低于40%，就开始断崖式下降，几乎没几分钟就要停电关机了。</p><p>而电量侦测是周期性的，并不是实时的，所以需要有一定的弹性空间。</p><h2 id="放飞自我"><a href="#放飞自我" class="headerlink" title="放飞自我"></a>放飞自我</h2><p>解决了电量的后顾之忧，可以安心使用了。</p><p>发挥想象力，可以做的事儿太多了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h2&gt;&lt;p&gt;家里有闲置的Android设备，有不限时、不限流量、拥有公网IP的宽带，总想着把它们利用起来。&lt;/p&gt;
&lt;p&gt;Android基于一个修改版的linux内核，有大把的开源软件可以运行在这个操作系统上。&lt;/p&gt;
&lt;p&gt;然而有一个问题，就是锂电池的使用与寿命，虽说是闲置、淘汰了的Android设备，但始终插着电源线充电显然不妥。&lt;/p&gt;
&lt;p&gt;比较理想的方式是，建立一个自动化的充电机制：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Android设备始终插着电源线，但并不是始终充电。当电池电量低（低于20%）时，能够自动启动充电，而电量高（超过90%）时，自动关闭充电。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最初使用了一个&lt;a href=&quot;https://www.mi.com/mj-socket/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;米家智能插座 基础版&lt;/a&gt;来实现。&lt;/p&gt;
&lt;p&gt;这里吐槽一下&lt;a href=&quot;https://home.mi.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;米家&lt;/a&gt;app，触发插座开关的可选项实在是太少，也没有提供公开的API。&lt;/p&gt;
&lt;p&gt;无奈已经买了硬件，自己挖的坑，自己填。&lt;/p&gt;
&lt;p&gt;过程不细说了（如果有感兴趣的读者留言，可以考虑另外写一篇），结果是：&lt;/p&gt;
&lt;p&gt;使用Android下的busybox中的crontab，周期性的检查 &lt;code&gt;/sys/class/power_supply/battery&lt;/code&gt; 下的电量信息。&lt;/p&gt;
&lt;p&gt;通过shell脚本，判断电量后，使用 &lt;code&gt;adb input keyevent&lt;/code&gt; 和 &lt;code&gt;adb input swipe&lt;/code&gt; 模拟屏幕操作。&lt;/p&gt;
&lt;p&gt;使用米家app，把智能插座usb口的开关，放两个快捷方式在Android的桌面上，通过模拟屏幕操作点击。&lt;/p&gt;
&lt;p&gt;如此实现了自动化充电的机制，这时可以把Android设备视作一个linux server，或者说，更像是一个Raspberry Pi，可以放飞自我了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="智能家庭" scheme="https://mu4yu3.github.io/tags/%E6%99%BA%E8%83%BD%E5%AE%B6%E5%BA%AD/"/>
    
      <category term="smart home" scheme="https://mu4yu3.github.io/tags/smart-home/"/>
    
      <category term="Home Assistant" scheme="https://mu4yu3.github.io/tags/Home-Assistant/"/>
    
      <category term="homebridge" scheme="https://mu4yu3.github.io/tags/homebridge/"/>
    
      <category term="HomeKit" scheme="https://mu4yu3.github.io/tags/HomeKit/"/>
    
  </entry>
  
  <entry>
    <title>USB redirection 的实验记录</title>
    <link href="https://mu4yu3.github.io/2018/01/10/usb_redirection/"/>
    <id>https://mu4yu3.github.io/2018/01/10/usb_redirection/</id>
    <published>2018-01-10T05:18:13.000Z</published>
    <updated>2018-01-15T05:05:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近遇到这样一个需求：</p><p>某USB设备（不限种类），物理上插在某A机器上，需要在某B系统中使用，而这个B系统，运行在某台服务器C的虚拟化环境中。<br>A、B、C系统可以通过网络相互访问。</p><p>这是前提。</p><p>再具体一下，A的系统可以不限定windows或者linux，B系统限定为windows，版本限定在7或更高版本。<br>另外，C系统所用虚拟化技术不限，可以考虑kvm、或者vmware、甚至virtualbox也可以。</p><p>这是现实。</p><p>众多的解决方案中，有不少商业方案，毕竟花钱可以解决大多数问题。</p><p>本文描述了开源方案。</p><p>想要直接得到答案的读者，可以绕过 <strong>弯路</strong> ，去 <strong>直路</strong> 看结果。</p><a id="more"></a><h2 id="弯路"><a href="#弯路" class="headerlink" title="弯路"></a>弯路</h2><p>通过google，找到了一个名叫 <a href="http://usbip.sourceforge.net" target="_blank" rel="noopener">USB/IP</a> 的开源项目。</p><p>看文档，它包括了linux的server和client端，甚至还包括一个windows版的client端，一切看上去都那么符合我们的需求。</p><p>可是实际测试的时候，发生了问题。</p><p>server端使用了fedora 26自带软件仓库的usbip。</p><p>client端使用了<a href="https://sourceforge.net/projects/usbip/files/usbip_windows/" target="_blank" rel="noopener">sourceforge提供的二进制包</a>。</p><p>连接报错。</p><h3 id="第1次尝试"><a href="#第1次尝试" class="headerlink" title="第1次尝试"></a>第1次尝试</h3><p>这篇<a href="https://sourceforge.net/p/usbip/discussion/418507/thread/7ff86875/" target="_blank" rel="noopener">帖子</a>里描述了类似的报错信息。</p><p>按照2楼的说法，修改了源码，重新编译（这里有个坑，看源码以为可以使用gcc编译，最终使用virtual studio 2010才编译成功）。</p><p>重新编译以后，使用 <code>usbip list</code> 命令可以看到server端bind的设备，但使用 <code>usbip attach</code> 的时候依然报错。</p><p>至此，基本放弃了windows端client的思路。</p><h3 id="第2次尝试"><a href="#第2次尝试" class="headerlink" title="第2次尝试"></a>第2次尝试</h3><p>kvm支持USB passthrough，直接将本机的usb设备，映射到虚拟机中。</p><p>所以问题可以转化为：在服务器中使用usbip的client端，先将usb设备映射到服务器本地，再通过kvm映射到虚拟机中。</p><p>这样可以绕过windows端的client问题，只要linux版的usbip可以使用就ok。（实际上，不只是这样就可以，还有一个隐患问题，后面会遇到。）</p><p>使用了2台笔记本做实验，两端分别使用了fedora的25、26版本，安装自带软件仓库的usbip，<code>dnf update</code> 到最新。</p><p>结果失败，<code>usbip list</code> 命令可以看到server端bind的设备，但使用 <code>usbip attach</code> 的时候报错。</p><p>尝试将一台fedora从25升级到26，保持server和client两端都是26，还是报错。</p><p>尝试将2台系统更换到ubuntu 16.04，报错。</p><p>尝试将2台系统更换到ubuntu 12.04，报错。</p><p>这真是见鬼了，还是第一次遇到发行版本自带的软件有这种bug的情况。</p><h3 id="第3次尝试"><a href="#第3次尝试" class="headerlink" title="第3次尝试"></a>第3次尝试</h3><p>还是回到源码里面找原因，<a href="https://sourceforge.net/p/usbip/git-windows/ci/master/tree/" target="_blank" rel="noopener">sourceforge上的源码</a>在2011年就停止更新了。</p><p>这个项目后续难道没人再维护了么？</p><p>仔细阅读了<a href="http://usbip.sourceforge.net" target="_blank" rel="noopener">项目主页</a>，有这样一段话：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">For Linux, the source code of usbip was merged into the staging tree, and finally has</span><br><span class="line">been moved to the mainline since Linux-3.17. Development is ongoing in the kernel</span><br><span class="line">community, not here. Linux distributions will provide binary packages of usbip. Just for</span><br><span class="line">historical records, the project page keeps old download files of the Linux version. Do</span><br><span class="line">not use them.</span><br></pre></td></tr></table></figure></p><p>原来如此，既然发行版本里面自带的usbip不好用，那么就去linux的源码里面找。</p><p>果然，在<a href="https://github.com/torvalds/linux" target="_blank" rel="noopener">linux的源码</a> <code>tools/usb/usbip</code> 目录下，找到了usbip的<a href="https://github.com/torvalds/linux/tree/master/tools/usb/usbip" target="_blank" rel="noopener">源代码</a>。</p><p>这时候再来看，当前fedora26，<code>dnf update</code> 到最新，自带的内核版本为 <code>4.14.11-200</code> ，而usbip的版本为 <code>4.9.9</code>。于是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/torvalds/linux.git</span><br></pre></td></tr></table></figure></p><p>敲完这个命令，就去睡觉。等一觉醒来，已经下好了，有3个G大小。</p><p>然后找到 <code>4.14</code> 版本的内核（对应fedora26，其他发行版本可能不一样）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout v4.14</span><br></pre></td></tr></table></figure></p><p>果然不愧是3G的git，在其他git库里面瞬间执行的命令，这里要等待30秒。</p><p>在 <code>tools/usb/usbip</code> 目录下，找到源码，按照readme的说明，编译源码。</p><p>这里单独使用了一个docker的容器，来进行编译工作。下载了fedora的官方镜像。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull fedora:26</span><br></pre></td></tr></table></figure></p><p>启动容器后，先安装编译环境：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf group install &quot;C Development Tools and Libraries&quot; -y</span><br></pre></td></tr></table></figure></p><p>将源码放到 <code>/opt/usbip</code> 目录下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./autogen.sh</span><br><span class="line">./configure</span><br></pre></td></tr></table></figure></p><p>这一步会报错，有缺少的库文件，通过dnf查找库文件的安装包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf provides /usr/include/libudev.h</span><br></pre></td></tr></table></figure></p><p>安装缺少的包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf install file systemd-devel -y</span><br></pre></td></tr></table></figure></p><p>再一次执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br><span class="line">./make</span><br></pre></td></tr></table></figure></p><p>成功后在 <code>/opt/usbip/src</code> 目录下可以看到 <code>usbip</code> 和 <code>usbipd</code> 这2个可执行文件。</p><p>把 <code>/opt/usbip</code> 整个目录 <code>scp</code> 到server端和client端的fedora系统里，放置在同样的目录下。</p><p>在server端运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/usbip/src</span><br><span class="line">modprobe usbip-core</span><br><span class="line">modprobe usbip-host</span><br><span class="line">./usbipd -D</span><br><span class="line">./usbip list -l</span><br><span class="line">./usbip bind --busid 2-1</span><br></pre></td></tr></table></figure></p><p>在client端运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/usbip/src</span><br><span class="line">modprobe usbip-core</span><br><span class="line">modprobe vhci-hcd</span><br><span class="line">./usbip list --remote 10.0.0.1</span><br><span class="line">./usbip attach --remote 10.0.0.1 --busid 2-1</span><br></pre></td></tr></table></figure></p><p>实验里映射的是一个usb的键鼠套装，至此，已经可以控制client端的操作。从linux到linux的usbip已经完成验证。</p><p>想要解除，可以在client端运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./usbip port</span><br><span class="line">./usbip detach --port 0</span><br></pre></td></tr></table></figure></p><p>在server端运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./usbip unbind --busid 2-1</span><br></pre></td></tr></table></figure></p><h3 id="埋伏的隐患"><a href="#埋伏的隐患" class="headerlink" title="埋伏的隐患"></a>埋伏的隐患</h3><p>还记得之前提到的隐患么，它出现在这里。</p><p>当把client端的usb设备，通过KVM的USB passthrough，映射到虚拟机中。</p><p>配置操作是可以完成的，然而它并不生效。</p><p>无论是配置后，启动虚拟机；或者先启动虚拟机，再添加USB设备，在虚拟系统里，它都不生效。</p><p>并且一旦虚拟机重启，usb设备在host系统也消失了。需要重启usbip的server和client端，才能重新映射过来。</p><p>换言之，无法满足最终需求。</p><h2 id="直路"><a href="#直路" class="headerlink" title="直路"></a>直路</h2><p>在使用kvm管理工具 <code>virt-manager</code> 的过程中，通过USB passthrough，映射本地usb设备。意外发现有usb重定向选项。</p><p>在usb重定向的类型选择中，除了Spice通道，还有TCP的方式，可以填写host和port。</p><p>顺着这个思路Google，找到名为 <code>usbredir-server</code> 的软件包。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf install usbredir-server -y</span><br></pre></td></tr></table></figure></p><p>通过观察usb设备前的 <usbbus-usbaddr|vendorid:prodid> 代码，类似 xxxx:xxxx 的形式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lsusb</span><br><span class="line">usbredirserver -p 55555 -v 3 xxxx:xxxx</span><br></pre></td></tr></table></figure></usbbus-usbaddr|vendorid:prodid></p><p>端口可以自定义。<br>verbosity level（-v）级别从0-5，0:Silent 1:Errors 2:Warnings 3:Info 4:Debug 5:Debug++。</p><p>这将把对应的usb设备映射到网上。可以通过 <code>netstat</code> 命令检查。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -altunp | grep &quot;usbredirserver&quot;</span><br></pre></td></tr></table></figure></p><p>client端，在kvm中配置（可以在 <code>virt-manager</code> 中设置，也可以直接修改域配置xml文件）TCP的host和port。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;redirdev bus=&apos;usb&apos; type=&apos;tcp&apos;&gt;</span><br><span class="line">  &lt;source mode=&apos;connect&apos; host=&apos;10.0.0.1&apos; service=&apos;55555&apos;/&gt;</span><br><span class="line">  &lt;protocol type=&apos;raw&apos;/&gt;</span><br><span class="line">  &lt;address type=&apos;usb&apos; bus=&apos;0&apos; port=&apos;9&apos;/&gt;</span><br><span class="line">&lt;/redirdev&gt;</span><br></pre></td></tr></table></figure></p><p>启动虚拟机，测试生效。</p><h3 id="hot-plug-redirdev-device"><a href="#hot-plug-redirdev-device" class="headerlink" title="hot-plug redirdev device"></a>hot-plug redirdev device</h3><p>关于重定向设备的热插拔，这里使用了 <code>virsh</code> 命令</p><p>如果在上一个步骤中没有修改配置文件，也就是在虚拟机启动时，尚未添加重定向设备，可以将上述文件内容单独保存为一个xml文件。</p><p>假设这个文件保存为 <code>usb_redir.xml</code>，启动的虚拟机，名称为 <code>test_vm</code>。</p><p>执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virsh attach-device test_vm usb_redir.xml --live</span><br></pre></td></tr></table></figure></p><p>可以成功附加远程设备。</p><p>而使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virsh detach-device test_vm usb_redir.xml --live</span><br></pre></td></tr></table></figure></p><p>则会报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error: Failed to detach device from usb_redir.xml</span><br><span class="line">error: Operation not supported: live detach of device &apos;redirdev&apos; is not supported</span><br></pre></td></tr></table></figure></p><p>看来在当前的 <code>virsh</code> 版本中， <code>redirdev</code> 设备还不支持hot unplugging。</p><p>好消息是：已经有人注意到类似问题并<a href="https://gitlab.com/libvirt/libvirt/commit/91a3234f3a218a581ede975164e66ce7b0347f4c" target="_blank" rel="noopener">提交了源码修改</a>。</p><h2 id="多说两句"><a href="#多说两句" class="headerlink" title="多说两句"></a>多说两句</h2><p>其实usb的重定向，也可以使用 <code>M$</code> 的RemoteFX，或者spice的远程来解决。</p><p>但这2个方案似乎都需要客户端保持远程连接，usb的重定向才能生效，一旦远程连接断开，usb的重定向也会断开。</p><p>所以并不在考虑的范围内。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近遇到这样一个需求：&lt;/p&gt;
&lt;p&gt;某USB设备（不限种类），物理上插在某A机器上，需要在某B系统中使用，而这个B系统，运行在某台服务器C的虚拟化环境中。&lt;br&gt;A、B、C系统可以通过网络相互访问。&lt;/p&gt;
&lt;p&gt;这是前提。&lt;/p&gt;
&lt;p&gt;再具体一下，A的系统可以不限定windows或者linux，B系统限定为windows，版本限定在7或更高版本。&lt;br&gt;另外，C系统所用虚拟化技术不限，可以考虑kvm、或者vmware、甚至virtualbox也可以。&lt;/p&gt;
&lt;p&gt;这是现实。&lt;/p&gt;
&lt;p&gt;众多的解决方案中，有不少商业方案，毕竟花钱可以解决大多数问题。&lt;/p&gt;
&lt;p&gt;本文描述了开源方案。&lt;/p&gt;
&lt;p&gt;想要直接得到答案的读者，可以绕过 &lt;strong&gt;弯路&lt;/strong&gt; ，去 &lt;strong&gt;直路&lt;/strong&gt; 看结果。&lt;/p&gt;
    
    </summary>
    
    
      <category term="usb重定向" scheme="https://mu4yu3.github.io/tags/usb%E9%87%8D%E5%AE%9A%E5%90%91/"/>
    
      <category term="usb over ip" scheme="https://mu4yu3.github.io/tags/usb-over-ip/"/>
    
      <category term="usbip" scheme="https://mu4yu3.github.io/tags/usbip/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://mu4yu3.github.io/2018/01/01/hello-world/"/>
    <id>https://mu4yu3.github.io/2018/01/01/hello-world/</id>
    <published>2018-01-01T13:45:23.000Z</published>
    <updated>2018-01-12T16:20:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>多少年了，没有再写过blog。</p><p>当年曾经在<code>M$</code>的<a href="https://zh.wikipedia.org/wiki/Windows_Live_Spaces" target="_blank" rel="noopener">MSN Spaces</a>写过博客。</p><p>后来msn spaces停止服务了，将blog迁移到sina，从那时候开始就很少写了。</p><p>其实也不是写的少，只是不再放在网络上了。</p><h2 id="现在"><a href="#现在" class="headerlink" title="现在"></a>现在</h2><p>最近使用github逐渐变多，对于开源、共享的想法也越来越多。</p><p>想要写点东西的念头又开始萌发。</p><p>“写个blog吧”，对自己说。</p><a id="more"></a><h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><p>其实写blog也有很多选择。</p><p>继续使用sina的也算；租一个vps，架一个WordPress也可以；或者另找一个第三方托管，比如Blogger。</p><p>但一来需要考虑到在大陆能访问，二来估计访问量较小，三来考虑未来迁移较方便，四来希望能有更多的控制权。</p><p>最终选择了<a href="https://pages.github.com" target="_blank" rel="noopener">GitHub Pages</a>，作为blog的托管。</p><p>选择了使用<a href="https://github.com/hexojs/hexo" target="_blank" rel="noopener">hexo</a>，作为blog框架。</p><p>选择了<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">next</a>，作为blog主题。</p><h2 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h2><p>其实这个blog能写多久、写些什么、将来会怎么样，都不太清楚。</p><p>也许只有这一篇，后面就没有了。</p><p>也许会写一些技术相关的文档，也许会写一些自己的感悟。</p><p>也许将来这里会成为一个交流的节点，也许这里只是自己的后花园。</p><p>但无论将来怎样，其实现在做什么才是更重要，更有意义的事儿，不是么？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;多少年了，没有再写过blog。&lt;/p&gt;
&lt;p&gt;当年曾经在&lt;code&gt;M$&lt;/code&gt;的&lt;a href=&quot;https://zh.wikipedia.org/wiki/Windows_Live_Spaces&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MSN Spaces&lt;/a&gt;写过博客。&lt;/p&gt;
&lt;p&gt;后来msn spaces停止服务了，将blog迁移到sina，从那时候开始就很少写了。&lt;/p&gt;
&lt;p&gt;其实也不是写的少，只是不再放在网络上了。&lt;/p&gt;
&lt;h2 id=&quot;现在&quot;&gt;&lt;a href=&quot;#现在&quot; class=&quot;headerlink&quot; title=&quot;现在&quot;&gt;&lt;/a&gt;现在&lt;/h2&gt;&lt;p&gt;最近使用github逐渐变多，对于开源、共享的想法也越来越多。&lt;/p&gt;
&lt;p&gt;想要写点东西的念头又开始萌发。&lt;/p&gt;
&lt;p&gt;“写个blog吧”，对自己说。&lt;/p&gt;
    
    </summary>
    
    
      <category term="心情" scheme="https://mu4yu3.github.io/tags/%E5%BF%83%E6%83%85/"/>
    
      <category term="杂谈" scheme="https://mu4yu3.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
</feed>
