<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lich&#39;s Blog</title>
  
  <subtitle>Just do IT.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://mu4yu3.github.io/"/>
  <updated>2018-01-12T16:20:11.000Z</updated>
  <id>https://mu4yu3.github.io/</id>
  
  <author>
    <name>Lich</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>USB redirection 的实验记录</title>
    <link href="https://mu4yu3.github.io/2018/01/10/usb_redirection/"/>
    <id>https://mu4yu3.github.io/2018/01/10/usb_redirection/</id>
    <published>2018-01-10T05:18:13.000Z</published>
    <updated>2018-01-12T16:20:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近遇到这样一个需求：</p><p>某USB设备（不限种类），物理上插在某A机器上，需要在某B系统中使用，而这个B系统，运行在某台服务器C的虚拟化环境中。<br>A、B、C系统可以通过网络相互访问。</p><p>这是前提。</p><p>再具体一下，A的系统可以不限定windows或者linux，B系统限定为windows，版本限定在7或更高版本。<br>另外，C系统所用虚拟化技术不限，可以考虑kvm、或者vmware、甚至virtualbox也可以。</p><p>这是现实。</p><p>众多的解决方案中，有不少商业方案，毕竟花钱可以解决大多数问题。</p><p>本文描述了开源方案。</p><p>想要直接得到答案的读者，可以绕过 <strong>弯路</strong> ，去 <strong>直路</strong> 看结果。</p><a id="more"></a><h2 id="弯路"><a href="#弯路" class="headerlink" title="弯路"></a>弯路</h2><p>通过google，找到了一个名叫 <a href="http://usbip.sourceforge.net" target="_blank" rel="noopener">USB/IP</a> 的开源项目。</p><p>看文档，它包括了linux的server和client端，甚至还包括一个windows版的client端，一切看上去都那么符合我们的需求。</p><p>可是实际测试的时候，发生了问题。</p><p>server端使用了fedora 26自带软件仓库的usbip。</p><p>client端使用了<a href="https://sourceforge.net/projects/usbip/files/usbip_windows/" target="_blank" rel="noopener">sourceforge提供的二进制包</a>。</p><p>连接报错。</p><h3 id="第1次尝试"><a href="#第1次尝试" class="headerlink" title="第1次尝试"></a>第1次尝试</h3><p>这篇<a href="https://sourceforge.net/p/usbip/discussion/418507/thread/7ff86875/" target="_blank" rel="noopener">帖子</a>里描述了类似的报错信息。</p><p>按照2楼的说法，修改了源码，重新编译（这里有个坑，看源码以为可以使用gcc编译，最终使用virtual studio 2010才编译成功）。</p><p>重新编译以后，使用 <code>usbip list</code> 命令可以看到server端bind的设备，但使用 <code>usbip attach</code> 的时候依然报错。</p><p>至此，基本放弃了windows端client的思路。</p><h3 id="第2次尝试"><a href="#第2次尝试" class="headerlink" title="第2次尝试"></a>第2次尝试</h3><p>kvm支持USB passthrough，直接将本机的usb设备，映射到虚拟机中。</p><p>所以问题可以转化为：在服务器中使用usbip的client端，先将usb设备映射到服务器本地，再通过kvm映射到虚拟机中。</p><p>这样可以绕过windows端的client问题，只要linux版的usbip可以使用就ok。（实际上，不只是这样就可以，还有一个隐患问题，后面会遇到。）</p><p>使用了2台笔记本做实验，两端分别使用了fedora的25、26版本，安装自带软件仓库的usbip，<code>dnf update</code> 到最新。</p><p>结果失败，<code>usbip list</code> 命令可以看到server端bind的设备，但使用 <code>usbip attach</code> 的时候报错。</p><p>尝试将一台fedora从25升级到26，保持server和client两端都是26，还是报错。</p><p>尝试将2台系统更换到ubuntu 16.04，报错。</p><p>尝试将2台系统更换到ubuntu 12.04，报错。</p><p>这真是见鬼了，还是第一次遇到发行版本自带的软件有这种bug的情况。</p><h3 id="第3次尝试"><a href="#第3次尝试" class="headerlink" title="第3次尝试"></a>第3次尝试</h3><p>还是回到源码里面找原因，<a href="https://sourceforge.net/p/usbip/git-windows/ci/master/tree/" target="_blank" rel="noopener">sourceforge上的源码</a>在2011年就停止更新了。</p><p>这个项目后续难道没人再维护了么？</p><p>仔细阅读了<a href="http://usbip.sourceforge.net" target="_blank" rel="noopener">项目主页</a>，有这样一段话：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">For Linux, the source code of usbip was merged into the staging tree, and finally has</span><br><span class="line">been moved to the mainline since Linux-3.17. Development is ongoing in the kernel</span><br><span class="line">community, not here. Linux distributions will provide binary packages of usbip. Just for</span><br><span class="line">historical records, the project page keeps old download files of the Linux version. Do</span><br><span class="line">not use them.</span><br></pre></td></tr></table></figure></p><p>原来如此，既然发行版本里面自带的usbip不好用，那么就去linux的源码里面找。</p><p>果然，在<a href="https://github.com/torvalds/linux" target="_blank" rel="noopener">linux的源码</a> <code>tools/usb/usbip</code> 目录下，找到了usbip的<a href="https://github.com/torvalds/linux/tree/master/tools/usb/usbip" target="_blank" rel="noopener">源代码</a>。</p><p>这时候再来看，当前fedora26，<code>dnf update</code> 到最新，自带的内核版本为 <code>4.14.11-200</code> ，而usbip的版本为 <code>4.9.9</code>。于是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/torvalds/linux.git</span><br></pre></td></tr></table></figure></p><p>敲完这个命令，就去睡觉。等一觉醒来，已经下好了，有3个G大小。</p><p>然后找到 <code>4.14</code> 版本的内核（对应fedora26，其他发行版本可能不一样）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout v4.14</span><br></pre></td></tr></table></figure></p><p>果然不愧是3G的git，在其他git库里面瞬间执行的命令，这里要等待30秒。</p><p>在 <code>tools/usb/usbip</code> 目录下，找到源码，按照readme的说明，编译源码。</p><p>这里单独使用了一个docker的容器，来进行编译工作。下载了fedora的官方镜像。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull fedora:26</span><br></pre></td></tr></table></figure></p><p>启动容器后，先安装编译环境：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf group install &quot;C Development Tools and Libraries&quot; -y</span><br></pre></td></tr></table></figure></p><p>将源码放到 <code>/opt/usbip</code> 目录下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./autogen.sh</span><br><span class="line">./configure</span><br></pre></td></tr></table></figure></p><p>这一步会报错，有缺少的库文件，通过dnf查找库文件的安装包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf provides /usr/include/libudev.h</span><br></pre></td></tr></table></figure></p><p>安装缺少的包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf install file systemd-devel -y</span><br></pre></td></tr></table></figure></p><p>再一次执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br><span class="line">./make</span><br></pre></td></tr></table></figure></p><p>成功后在 <code>/opt/usbip/src</code> 目录下可以看到 <code>usbip</code> 和 <code>usbipd</code> 这2个可执行文件。</p><p>把 <code>/opt/usbip</code> 整个目录 <code>scp</code> 到server端和client端的fedora系统里，放置在同样的目录下。</p><p>在server端运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/usbip/src</span><br><span class="line">modprobe usbip-core</span><br><span class="line">modprobe usbip-host</span><br><span class="line">./usbipd -D</span><br><span class="line">./usbip list -l</span><br><span class="line">./usbip bind --busid 2-1</span><br></pre></td></tr></table></figure></p><p>在client端运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/usbip/src</span><br><span class="line">modprobe usbip-core</span><br><span class="line">modprobe vhci-hcd</span><br><span class="line">./usbip list --remote 10.0.0.1</span><br><span class="line">./usbip attach --remote 10.0.0.1 --busid 2-1</span><br></pre></td></tr></table></figure></p><p>实验里映射的是一个usb的键鼠套装，至此，已经可以控制client端的操作。从linux到linux的usbip已经完成验证。</p><p>想要解除，可以在client端运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./usbip port</span><br><span class="line">./usbip detach --port 0</span><br></pre></td></tr></table></figure></p><p>在server端运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./usbip unbind --busid 2-1</span><br></pre></td></tr></table></figure></p><h3 id="埋伏的隐患"><a href="#埋伏的隐患" class="headerlink" title="埋伏的隐患"></a>埋伏的隐患</h3><p>还记得之前提到的隐患么，它出现在这里。</p><p>当把client端的usb设备，通过KVM的USB passthrough，映射到虚拟机中。</p><p>配置操作是可以完成的，然而它并不生效。</p><p>无论是配置后，启动虚拟机；或者先启动虚拟机，再添加USB设备，在虚拟系统里，它都不生效。</p><p>并且一旦虚拟机重启，usb设备在host系统也消失了。需要重启usbip的server和client端，才能重新映射过来。</p><p>换言之，无法满足最终需求。</p><h2 id="直路"><a href="#直路" class="headerlink" title="直路"></a>直路</h2><p>在使用kvm管理工具 <code>virt-manager</code> 的过程中，通过USB passthrough，映射本地usb设备。意外发现有usb重定向选项。</p><p>在usb重定向的类型选择中，除了Spice通道，还有TCP的方式，可以填写host和port。</p><p>顺着这个思路Google，找到名为 <code>usbredir-server</code> 的软件包。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf install usbredir-server -y</span><br></pre></td></tr></table></figure></p><p>通过观察usb设备前的 <usbbus-usbaddr|vendorid:prodid> 代码，类似 xxxx:xxxx 的形式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lsusb</span><br><span class="line">usbredirserver -p 55555 -v 3 xxxx:xxxx</span><br></pre></td></tr></table></figure></usbbus-usbaddr|vendorid:prodid></p><p>端口可以自定义。<br>verbosity level（-v）级别从0-5，0:Silent 1:Errors 2:Warnings 3:Info 4:Debug 5:Debug++。</p><p>这将把对应的usb设备映射到网上。可以通过 <code>netstat</code> 命令检查。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -altunp | grep &quot;usbredirserver&quot;</span><br></pre></td></tr></table></figure></p><p>client端，在kvm中配置（可以在 <code>virt-manager</code> 中设置，也可以直接修改域配置xml文件）TCP的host和port。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;redirdev bus=&apos;usb&apos; type=&apos;tcp&apos;&gt;</span><br><span class="line">  &lt;source mode=&apos;connect&apos; host=&apos;10.0.0.1&apos; service=&apos;55555&apos;/&gt;</span><br><span class="line">  &lt;protocol type=&apos;raw&apos;/&gt;</span><br><span class="line">  &lt;address type=&apos;usb&apos; bus=&apos;0&apos; port=&apos;9&apos;/&gt;</span><br><span class="line">&lt;/redirdev&gt;</span><br></pre></td></tr></table></figure></p><p>启动虚拟机，测试生效。</p><h2 id="多说两句"><a href="#多说两句" class="headerlink" title="多说两句"></a>多说两句</h2><p>其实usb的重定向，也可以使用 <code>M$</code> 的RemoteFX，或者spice的远程来解决。</p><p>但这2个方案似乎都需要客户端保持远程连接，usb的重定向才能生效，一旦远程连接断开，usb的重定向也会断开。</p><p>所以并不在考虑的范围内。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近遇到这样一个需求：&lt;/p&gt;
&lt;p&gt;某USB设备（不限种类），物理上插在某A机器上，需要在某B系统中使用，而这个B系统，运行在某台服务器C的虚拟化环境中。&lt;br&gt;A、B、C系统可以通过网络相互访问。&lt;/p&gt;
&lt;p&gt;这是前提。&lt;/p&gt;
&lt;p&gt;再具体一下，A的系统可以不限定windows或者linux，B系统限定为windows，版本限定在7或更高版本。&lt;br&gt;另外，C系统所用虚拟化技术不限，可以考虑kvm、或者vmware、甚至virtualbox也可以。&lt;/p&gt;
&lt;p&gt;这是现实。&lt;/p&gt;
&lt;p&gt;众多的解决方案中，有不少商业方案，毕竟花钱可以解决大多数问题。&lt;/p&gt;
&lt;p&gt;本文描述了开源方案。&lt;/p&gt;
&lt;p&gt;想要直接得到答案的读者，可以绕过 &lt;strong&gt;弯路&lt;/strong&gt; ，去 &lt;strong&gt;直路&lt;/strong&gt; 看结果。&lt;/p&gt;
    
    </summary>
    
    
      <category term="usb重定向" scheme="https://mu4yu3.github.io/tags/usb%E9%87%8D%E5%AE%9A%E5%90%91/"/>
    
      <category term="usb over ip" scheme="https://mu4yu3.github.io/tags/usb-over-ip/"/>
    
      <category term="usbip" scheme="https://mu4yu3.github.io/tags/usbip/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://mu4yu3.github.io/2018/01/01/hello-world/"/>
    <id>https://mu4yu3.github.io/2018/01/01/hello-world/</id>
    <published>2018-01-01T13:45:23.000Z</published>
    <updated>2018-01-12T16:20:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>多少年了，没有再写过blog。</p><p>当年曾经在<code>M$</code>的<a href="https://zh.wikipedia.org/wiki/Windows_Live_Spaces" target="_blank" rel="noopener">MSN Spaces</a>写过博客。</p><p>后来msn spaces停止服务了，将blog迁移到sina，从那时候开始就很少写了。</p><p>其实也不是写的少，只是不再放在网络上了。</p><h2 id="现在"><a href="#现在" class="headerlink" title="现在"></a>现在</h2><p>最近使用github逐渐变多，对于开源、共享的想法也越来越多。</p><p>想要写点东西的念头又开始萌发。</p><p>“写个blog吧”，对自己说。</p><a id="more"></a><h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><p>其实写blog也有很多选择。</p><p>继续使用sina的也算；租一个vps，架一个WordPress也可以；或者另找一个第三方托管，比如Blogger。</p><p>但一来需要考虑到在大陆能访问，二来估计访问量较小，三来考虑未来迁移较方便，四来希望能有更多的控制权。</p><p>最终选择了<a href="https://pages.github.com" target="_blank" rel="noopener">GitHub Pages</a>，作为blog的托管。</p><p>选择了使用<a href="https://github.com/hexojs/hexo" target="_blank" rel="noopener">hexo</a>，作为blog框架。</p><p>选择了<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">next</a>，作为blog主题。</p><h2 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h2><p>其实这个blog能写多久、写些什么、将来会怎么样，都不太清楚。</p><p>也许只有这一篇，后面就没有了。</p><p>也许会写一些技术相关的文档，也许会写一些自己的感悟。</p><p>也许将来这里会成为一个交流的节点，也许这里只是自己的后花园。</p><p>但无论将来怎样，其实现在做什么才是更重要，更有意义的事儿，不是么？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;多少年了，没有再写过blog。&lt;/p&gt;
&lt;p&gt;当年曾经在&lt;code&gt;M$&lt;/code&gt;的&lt;a href=&quot;https://zh.wikipedia.org/wiki/Windows_Live_Spaces&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MSN Spaces&lt;/a&gt;写过博客。&lt;/p&gt;
&lt;p&gt;后来msn spaces停止服务了，将blog迁移到sina，从那时候开始就很少写了。&lt;/p&gt;
&lt;p&gt;其实也不是写的少，只是不再放在网络上了。&lt;/p&gt;
&lt;h2 id=&quot;现在&quot;&gt;&lt;a href=&quot;#现在&quot; class=&quot;headerlink&quot; title=&quot;现在&quot;&gt;&lt;/a&gt;现在&lt;/h2&gt;&lt;p&gt;最近使用github逐渐变多，对于开源、共享的想法也越来越多。&lt;/p&gt;
&lt;p&gt;想要写点东西的念头又开始萌发。&lt;/p&gt;
&lt;p&gt;“写个blog吧”，对自己说。&lt;/p&gt;
    
    </summary>
    
    
      <category term="心情" scheme="https://mu4yu3.github.io/tags/%E5%BF%83%E6%83%85/"/>
    
      <category term="杂谈" scheme="https://mu4yu3.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
</feed>
